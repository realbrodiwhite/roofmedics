"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vis.gl";
exports.ids = ["vendor-chunks/@vis.gl"];
exports.modules = {

/***/ "(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APILoadingStatus: () => (/* binding */ APILoadingStatus),\n/* harmony export */   APIProvider: () => (/* binding */ APIProvider),\n/* harmony export */   APIProviderContext: () => (/* binding */ APIProviderContext),\n/* harmony export */   AdvancedMarker: () => (/* binding */ AdvancedMarker),\n/* harmony export */   AdvancedMarkerContext: () => (/* binding */ AdvancedMarkerContext),\n/* harmony export */   ControlPosition: () => (/* binding */ ControlPosition),\n/* harmony export */   GoogleMapsContext: () => (/* binding */ GoogleMapsContext),\n/* harmony export */   InfoWindow: () => (/* binding */ InfoWindow),\n/* harmony export */   Map: () => (/* binding */ Map),\n/* harmony export */   MapControl: () => (/* binding */ MapControl),\n/* harmony export */   Marker: () => (/* binding */ Marker),\n/* harmony export */   Pin: () => (/* binding */ Pin),\n/* harmony export */   isLatLngLiteral: () => (/* binding */ isLatLngLiteral),\n/* harmony export */   latLngEquals: () => (/* binding */ latLngEquals),\n/* harmony export */   limitTiltRange: () => (/* binding */ limitTiltRange),\n/* harmony export */   toLatLngLiteral: () => (/* binding */ toLatLngLiteral),\n/* harmony export */   useAdvancedMarkerRef: () => (/* binding */ useAdvancedMarkerRef),\n/* harmony export */   useApiIsLoaded: () => (/* binding */ useApiIsLoaded),\n/* harmony export */   useApiLoadingStatus: () => (/* binding */ useApiLoadingStatus),\n/* harmony export */   useMap: () => (/* binding */ useMap),\n/* harmony export */   useMapsLibrary: () => (/* binding */ useMapsLibrary),\n/* harmony export */   useMarkerRef: () => (/* binding */ useMarkerRef)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fast-deep-equal */ \"(ssr)/./node_modules/fast-deep-equal/index.js\");\n\n\n\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(params, onLoadingStatusChange) {\n    var _window$google;\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n    this.listeners.push(onLoadingStatusChange);\n    // Note: if `google.maps.importLibrary` has been defined externally, we\n    //   assume that loading is complete and successful.\n    //   If it was defined by a previous call to this method, a warning\n    //   message is logged if there are differences in api-parameters used\n    //   for both calls.\n    if ((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary) {\n      // no serialized parameters means it was loaded externally\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n      this.notifyLoadingStatusListeners();\n    } else {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params);\n    }\n    if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n      console.warn(`[google-maps-api-loader] The maps API has already been loaded ` + `with different parameters and will not be loaded again. Refresh the ` + `page for new values to have effect.`);\n    }\n    const librariesToLoad = ['maps', ...libraries];\n    await Promise.all(librariesToLoad.map(name => google.maps.importLibrary(name)));\n  }\n  /**\n   * Serialize the paramters used to load the library for easier comparison.\n   */\n  static serializeParams(params) {\n    return [params.v, params.key, params.language, params.region, params.authReferrerPolicy, params.solutionChannel].join('/');\n  }\n  /**\n   * Creates the global `google.maps.importLibrary` function for bootstrapping.\n   * This is essentially a formatted version of the dynamic loading script\n   * from the official documentation with some minor adjustments.\n   *\n   * The created importLibrary function will load the Google Maps JavaScript API,\n   * which will then replace the `google.maps.importLibrary` function with the full\n   * implementation.\n   *\n   * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n   */\n  static initImportLibrary(params) {\n    if (!window.google) window.google = {};\n    if (!window.google.maps) window.google.maps = {};\n    if (window.google.maps['importLibrary']) {\n      console.error('[google-maps-api-loader-internal]: initImportLibrary must only be called once');\n      return;\n    }\n    let apiPromise = null;\n    const loadApi = () => {\n      if (apiPromise) return apiPromise;\n      apiPromise = new Promise((resolve, reject) => {\n        var _document$querySelect;\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('loading', 'async');\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.async = true;\n        scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n        scriptElement.nonce = ((_document$querySelect = document.querySelector('script[nonce]')) == null ? void 0 : _document$querySelect.nonce) || '';\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          this.notifyLoadingStatusListeners();\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          this.notifyLoadingStatusListeners();\n          resolve();\n        };\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          this.notifyLoadingStatusListeners();\n        };\n        this.loadingStatus = APILoadingStatus.LOADING;\n        this.notifyLoadingStatusListeners();\n        document.head.append(scriptElement);\n      });\n      return apiPromise;\n    };\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName => loadApi().then(() => google.maps.importLibrary(libraryName));\n  }\n  /**\n   * Calls all registered loadingStatusListeners after a status update.\n   */\n  static notifyLoadingStatusListeners() {\n    for (const fn of this.listeners) {\n      fn(this.loadingStatus);\n    }\n  }\n}\n/**\n * The current loadingStatus of the API.\n */\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * The parameters used for first loading the API.\n */\nGoogleMapsApiLoader.serializedApiParams = void 0;\n/**\n * A list of functions to be notified when the loading status changes.\n */\nGoogleMapsApiLoader.listeners = [];\n\nconst _excluded$3 = [\"onLoad\", \"apiKey\", \"version\", \"libraries\"],\n  _excluded2 = [\"children\"];\nconst APIProviderContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const addMapInstance = (mapInstance, id = 'default') => {\n    setMapInstances(instances => _extends({}, instances, {\n      [id]: mapInstance\n    }));\n  };\n  const removeMapInstance = (id = 'default') => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(_ref => {\n      let remaining = _objectWithoutPropertiesLoose(_ref, [id].map(_toPropertyKey));\n      return remaining;\n    });\n  };\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n  return {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n  const {\n      onLoad,\n      apiKey,\n      version,\n      libraries = []\n    } = props,\n    otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$3);\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(GoogleMapsApiLoader.loadingStatus);\n  const [loadedLibraries, addLoadedLibrary] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((loadedLibraries, action) => {\n    return _extends({}, loadedLibraries, {\n      [action.name]: action.value\n    });\n  }, {});\n  const librariesString = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => libraries == null ? void 0 : libraries.join(','), [libraries]);\n  const serializedParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => JSON.stringify(_extends({\n    apiKey,\n    version\n  }, otherApiParams)), [apiKey, version, otherApiParams]);\n  const importLibrary = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async name => {\n    var _google;\n    if (loadedLibraries[name]) {\n      return loadedLibraries[name];\n    }\n    if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n      throw new Error('[api-provider-internal] importLibrary was called before ' + 'google.maps.importLibrary was defined.');\n    }\n    const res = await window.google.maps.importLibrary(name);\n    addLoadedLibrary({\n      name,\n      value: res\n    });\n    return res;\n  }, [loadedLibraries]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    (async () => {\n      try {\n        const params = _extends({\n          key: apiKey\n        }, otherApiParams);\n        if (version) params.v = version;\n        if ((librariesString == null ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n        await GoogleMapsApiLoader.load(params, status => setStatus(status));\n        for (const name of ['core', 'maps', ...libraries]) {\n          await importLibrary(name);\n        }\n        if (onLoad) {\n          onLoad();\n        }\n      } catch (error) {\n        console.error('<ApiProvider> failed to load Google Maps API', error);\n      }\n    })();\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [apiKey, librariesString, serializedParams]);\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n  const {\n      children\n    } = props,\n    loaderProps = _objectWithoutPropertiesLoose(props, _excluded2);\n  const {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  } = useMapInstances();\n  const {\n    status,\n    loadedLibraries,\n    importLibrary\n  } = useGoogleMapsApiLoader(loaderProps);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances,\n    status,\n    loadedLibraries,\n    importLibrary\n  }), [mapInstances, addMapInstance, removeMapInstance, clearMapInstances, status, loadedLibraries, importLibrary]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(APIProviderContext.Provider, {\n    value: contextValue\n  }, children);\n};\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, props) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName];\n    const eventType = propNameToEventType[propName];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (!map) return;\n      if (!handler) return;\n      const listener = google.maps.event.addListener(map, eventType, ev => {\n        handler(createMapEvent(eventType, map, ev));\n      });\n      return () => listener.remove();\n    }, [map, eventType, handler]);\n  }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n  const ev = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev;\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn('[createEvent] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    camEvent.detail = {\n      center: (center == null ? void 0 : center.toJSON()) || {\n        lat: 0,\n        lng: 0\n      },\n      zoom: zoom || 0,\n      heading: heading,\n      tilt: tilt,\n      bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    var _srcEvent$latLng;\n    if (!srcEvent) throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev;\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n    mouseEvent.detail = {\n      latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n      placeId: srcEvent.placeId\n    };\n    return mouseEvent;\n  }\n  return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed',\n  // note: onCameraChanged is an alias for the bounds_changed event,\n  // since that is going to be fired in every situation where the camera is\n  // updated.\n  onCameraChanged: 'bounds_changed'\n};\nconst cameraEventTypes = ['bounds_changed', 'center_changed', 'heading_changed', 'projection_changed', 'tilt_changed', 'zoom_changed'];\nconst mouseEventTypes = ['click', 'contextmenu', 'dblclick', 'mousemove', 'mouseout', 'mouseover'];\nconst eventPropNames = Object.keys(propNameToEventType);\n\nfunction useDeepCompareEffect(effect, deps) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n  if (!ref.current || !fast_deep_equal__WEBPACK_IMPORTED_MODULE_2__(deps, ref.current)) {\n    ref.current = deps;\n  }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(effect, ref.current);\n}\n\nconst mapOptionKeys = new Set(['backgroundColor', 'clickableIcons', 'controlSize', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'fullscreenControl', 'fullscreenControlOptions', 'gestureHandling', 'isFractionalZoomEnabled', 'keyboardShortcuts', 'mapTypeControl', 'mapTypeControlOptions', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'panControl', 'panControlOptions', 'restriction', 'rotateControl', 'rotateControlOptions', 'scaleControl', 'scaleControlOptions', 'scrollwheel', 'streetView', 'streetViewControl', 'streetViewControlOptions', 'styles', 'zoomControl', 'zoomControlOptions']);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, mapProps) {\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */\n  const mapOptions = {};\n  const keys = Object.keys(mapProps);\n  for (const key of keys) {\n    if (!mapOptionKeys.has(key)) continue;\n    mapOptions[key] = mapProps[key];\n  }\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useDeepCompareEffect(() => {\n    if (!map) return;\n    map.setOptions(mapOptions);\n  }, [mapOptions]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n\nfunction useApiLoadingStatus() {\n  var _useContext;\n  return ((_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, props) {\n  const {\n    viewport,\n    viewState\n  } = props;\n  const isDeckGlControlled = !!viewport;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map || !viewState) return;\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState;\n    map.moveCamera({\n      center: {\n        lat: latitude,\n        lng: longitude\n      },\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n  return isDeckGlControlled;\n}\n\nfunction isLatLngLiteral(obj) {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n  if (!a || !b) return false;\n  const A = toLatLngLiteral(a);\n  const B = toLatLngLiteral(b);\n  if (A.lat !== B.lat || A.lng !== B.lng) return false;\n  return true;\n}\nfunction toLatLngLiteral(obj) {\n  if (isLatLngLiteral(obj)) return obj;\n  return obj.toJSON();\n}\n\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n  const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n  const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n  const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n  // the following effect runs for every render of the map component and checks\n  // if there are differences between the known state of the map instance\n  // (cameraStateRef, which is updated by all bounds_changed events) and the\n  // desired state in the props.\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map) return;\n    const nextCamera = {};\n    let needsUpdate = false;\n    if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n      nextCamera.center = {\n        lat,\n        lng\n      };\n      needsUpdate = true;\n    }\n    if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n      nextCamera.zoom = zoom;\n      needsUpdate = true;\n    }\n    if (heading !== null && cameraStateRef.current.heading !== heading) {\n      nextCamera.heading = heading;\n      needsUpdate = true;\n    }\n    if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n      nextCamera.tilt = tilt;\n      needsUpdate = true;\n    }\n    if (needsUpdate) {\n      map.moveCamera(nextCamera);\n    }\n  });\n}\n\nconst AuthFailureMessage = () => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    style: style\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\n\nfunction useCallbackRef() {\n  const [el, setEl] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(value => setEl(value), [setEl]);\n  return [el, ref];\n}\n\n/**\n * Hook to check if the Google Maps API is loaded\n */\nfunction useApiIsLoaded() {\n  const status = useApiLoadingStatus();\n  return status === APILoadingStatus.LOADED;\n}\n\nfunction useForceUpdate() {\n  const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(x => x + 1, 0);\n  return forceUpdate;\n}\n\nfunction handleBoundsChange(map, ref) {\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const heading = map.getHeading() || 0;\n  const tilt = map.getTilt() || 0;\n  const bounds = map.getBounds();\n  if (!center || !bounds || !Number.isFinite(zoom)) {\n    console.warn('[useTrackedCameraState] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n  }\n  // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n  Object.assign(ref.current, {\n    center: (center == null ? void 0 : center.toJSON()) || {\n      lat: 0,\n      lng: 0\n    },\n    zoom: zoom || 0,\n    heading: heading,\n    tilt: tilt\n  });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nfunction useTrackedCameraStateRef(map) {\n  const forceUpdate = useForceUpdate();\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    center: {\n      lat: 0,\n      lng: 0\n    },\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n  // Record camera state with every bounds_changed event dispatched by the map.\n  // This data is used to prevent feeding these values back to the\n  // map-instance when a typical \"controlled component\" setup (state variable is\n  // fed into and updated by the map).\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    const listener = google.maps.event.addListener(map, 'bounds_changed', () => {\n      handleBoundsChange(map, ref);\n      // When an event is occured, we have to update during the next cycle.\n      // The application could decide to ignore the event and not update any\n      // camera props of the map, meaning that in that case we will have to\n      // 'undo' the change to the camera.\n      forceUpdate();\n    });\n    return () => listener.remove();\n  }, [map, forceUpdate]);\n  return ref;\n}\n\nconst _excluded$2 = [\"id\", \"defaultBounds\", \"defaultCenter\", \"defaultZoom\", \"defaultHeading\", \"defaultTilt\"];\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(props, context) {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [container, containerRef] = useCallbackRef();\n  const cameraStateRef = useTrackedCameraStateRef(map);\n  const {\n      id,\n      defaultBounds,\n      defaultCenter,\n      defaultZoom,\n      defaultHeading,\n      defaultTilt\n    } = props,\n    mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n  // apply default camera props if available and not overwritten by controlled props\n  if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n  if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n  if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n  if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n  for (const key of Object.keys(mapOptions)) if (mapOptions[key] === undefined) delete mapOptions[key];\n  const savedMapStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  // create the map instance and register it in the context\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!container || !apiIsLoaded) return;\n    const {\n      addMapInstance,\n      removeMapInstance\n    } = context;\n    const mapId = props.mapId;\n    const newMap = new google.maps.Map(container, mapOptions);\n    setMap(newMap);\n    addMapInstance(newMap, id);\n    if (defaultBounds) {\n      newMap.fitBounds(defaultBounds);\n    }\n    // the savedMapState is used to restore the camera parameters when the mapId is changed\n    if (savedMapStateRef.current) {\n      const {\n        mapId: savedMapId,\n        cameraState: savedCameraState\n      } = savedMapStateRef.current;\n      if (savedMapId !== mapId) {\n        newMap.setOptions(savedCameraState);\n      }\n    }\n    return () => {\n      savedMapStateRef.current = {\n        mapId,\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        cameraState: cameraStateRef.current\n      };\n      // remove all event-listeners to minimize memory-leaks\n      google.maps.event.clearInstanceListeners(newMap);\n      setMap(null);\n      removeMapInstance(id);\n    };\n  },\n  // some dependencies are ignored in the list below:\n  //  - defaultBounds and the default* camera props will only be used once, and\n  //    changes should be ignored\n  //  - mapOptions has special hooks that take care of updating the options\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [container, apiIsLoaded, id, props.mapId]);\n  return [map, containerRef, cameraStateRef];\n}\n\nconst GoogleMapsContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst Map = props => {\n  const {\n    children,\n    id,\n    className,\n    style\n  } = props;\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n  if (!context) {\n    throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n  }\n  const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n  useMapCameraParams(map, cameraStateRef, props);\n  useMapEvents(map, props);\n  useMapOptions(map, props);\n  const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n  const isControlledExternally = !!props.controlled;\n  // disable interactions with the map for externally controlled maps\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n    //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n    //   any default map controls pretty much useless\n    if (isDeckGlControlled) {\n      map.setOptions({\n        disableDefaultUI: true\n      });\n    }\n    // disable all control-inputs when the map is controlled externally\n    if (isDeckGlControlled || isControlledExternally) {\n      map.setOptions({\n        gestureHandling: 'none',\n        keyboardShortcuts: false\n      });\n    }\n    return () => {\n      map.setOptions({\n        gestureHandling: props.gestureHandling,\n        keyboardShortcuts: props.keyboardShortcuts\n      });\n    };\n  }, [map, isDeckGlControlled, isControlledExternally, props.gestureHandling, props.keyboardShortcuts]);\n  // setup a stable cameraOptions object that can be used as dependency\n  const center = props.center ? toLatLngLiteral(props.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const cameraOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    var _lat, _lng, _props$zoom, _props$heading, _props$tilt;\n    return {\n      center: {\n        lat: (_lat = lat) != null ? _lat : 0,\n        lng: (_lng = lng) != null ? _lng : 0\n      },\n      zoom: (_props$zoom = props.zoom) != null ? _props$zoom : 0,\n      heading: (_props$heading = props.heading) != null ? _props$heading : 0,\n      tilt: (_props$tilt = props.tilt) != null ? _props$tilt : 0\n    };\n  }, [lat, lng, props.zoom, props.heading, props.tilt]);\n  // externally controlled mode: reject all camera changes that don't correspond to changes in props\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!map || !isControlledExternally) return;\n    map.moveCamera(cameraOptions);\n    const listener = map.addListener('bounds_changed', () => {\n      map.moveCamera(cameraOptions);\n    });\n    return () => listener.remove();\n  }, [map, isControlledExternally, cameraOptions]);\n  const combinedStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => _extends({\n    width: '100%',\n    height: '100%',\n    // when using deckgl, the map should be sent to the back\n    zIndex: isDeckGlControlled ? -1 : 0\n  }, style), [style, isDeckGlControlled]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    map\n  }), [map]);\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n      style: _extends({\n        position: 'relative'\n      }, className ? {} : combinedStyle),\n      className: className\n    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AuthFailureMessage, null));\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", _extends({\n    ref: mapRef,\n    \"data-testid\": 'map',\n    style: className ? undefined : combinedStyle,\n    className: className\n  }, id ? {\n    id\n  } : {}), map ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(GoogleMapsContext.Provider, {\n    value: contextValue\n  }, children) : null);\n};\nMap.deckGLViewProps = true;\n\nfunction useMapsLibrary(name) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!apiIsLoaded || !ctx) return;\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx, name]);\n  return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable complexity */\nconst AdvancedMarkerContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction useAdvancedMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const markerLibrary = useMapsLibrary('marker');\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n  const numChilds = react__WEBPACK_IMPORTED_MODULE_0__.Children.count(children);\n  // create marker instance and add it to the map when map becomes available\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map || !markerLibrary) return;\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n    setMarker(newMarker);\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.className = className;\n      newMarker.content = el;\n      setContentContainer(el);\n    }\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n    // We do not want to re-render the whole marker when the className changes\n    // because that causes a short flickering of the marker.\n    // The className update is handled in the useEffect below.\n    // Excluding the className from the dependency array onm purpose here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, markerLibrary, numChilds]);\n  // update className of advanced marker element\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!contentContainer) return;\n    contentContainer.className = className != null ? className : '';\n  }, [contentContainer, className]);\n  // bind all marker events\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(marker, 'click', onClick);\n    if (onDrag) gme.addListener(marker, 'drag', onDrag);\n    if (onDragStart) gme.addListener(marker, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(marker, 'dragend', onDragEnd);\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn('You need to set the marker to draggable to listen to drag-events.');\n    }\n    const m = marker;\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n  // update other marker props when changed\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined) marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n  return [marker, contentContainer];\n}\nconst AdvancedMarker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const {\n    children\n  } = props;\n  const [marker, contentContainer] = useAdvancedMarker(props);\n  const advancedMarkerContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => marker ? {\n    marker\n  } : null, [marker]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n  if (!marker) {\n    return null;\n  }\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(AdvancedMarkerContext.Provider, {\n    value: advancedMarkerContextValue\n  }, contentContainer !== null && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n});\nfunction useAdvancedMarkerRef() {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\nconst _excluded$1 = [\"children\", \"anchor\", \"shouldFocus\", \"onCloseClick\"];\n/**\n * Component to render a Google Maps Info Window\n */\nconst InfoWindow = props => {\n  var _useContext;\n  const {\n      children,\n      anchor,\n      shouldFocus,\n      onCloseClick\n    } = props,\n    infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n  const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const infoWindowRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [contentContainer, setContentContainer] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  // create infowindow once map is available\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    const newInfowindow = new google.maps.InfoWindow(infoWindowOptions);\n    // Add content to info window\n    const el = document.createElement('div');\n    newInfowindow.setContent(el);\n    infoWindowRef.current = newInfowindow;\n    setContentContainer(el);\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(newInfowindow);\n      newInfowindow.close();\n      el.remove();\n      setContentContainer(null);\n    };\n    // `infoWindowOptions` is missing from dependencies:\n    //\n    // we don't want to re-render a whole new infowindow\n    // when the options change to prevent flickering.\n    // Update of infoWindow options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, children]);\n  // Update infoWindowOptions\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    var _infoWindowRef$curren;\n    (_infoWindowRef$curren = infoWindowRef.current) == null || _infoWindowRef$curren.setOptions(infoWindowOptions);\n  }, [infoWindowOptions]);\n  // Handle the close click callback\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!infoWindowRef.current) return;\n    let listener = null;\n    if (onCloseClick) {\n      listener = google.maps.event.addListener(infoWindowRef.current, 'closeclick', onCloseClick);\n    }\n    return () => {\n      if (listener) listener.remove();\n    };\n  }, [onCloseClick]);\n  // Open info window after content container is set\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // anchor === null means an anchor is defined but not ready yet.\n    if (!contentContainer || !infoWindowRef.current || anchor === null) return;\n    const openOptions = {\n      map\n    };\n    if (anchor) {\n      openOptions.anchor = anchor;\n    }\n    if (shouldFocus !== undefined) {\n      openOptions.shouldFocus = shouldFocus;\n    }\n    infoWindowRef.current.open(openOptions);\n  }, [contentContainer, infoWindowRef, anchor, map, shouldFocus]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, contentContainer !== null && (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, contentContainer));\n};\n\nconst shownMessages = new Set();\nfunction logErrorOnce(...args) {\n  const key = JSON.stringify(args);\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n    console.error(...args);\n  }\n}\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = (id = null) => {\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(APIProviderContext);\n  const {\n    map\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext) || {};\n  if (ctx === null) {\n    logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' + 'Make sure that the <APIProvider> component exists and that the ' + 'component you are calling `useMap()` from is a sibling of the ' + '<APIProvider>.');\n    return null;\n  }\n  const {\n    mapInstances\n  } = ctx;\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n  // otherwise, return the closest ancestor\n  if (map) return map;\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n};\nconst MapControl = ({\n  children,\n  position\n}) => {\n  const controlContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n  const map = useMap();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) return;\n    const controls = map.controls[position];\n    controls.push(controlContainer);\n    return () => {\n      const controlsArray = controls.getArray();\n      // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n      if (!controlsArray) return;\n      const index = controlsArray.indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [controlContainer, map, position]);\n  return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, controlContainer);\n};\n\nconst _excluded = [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"];\nfunction useMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const map = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const {\n      onClick,\n      onDrag,\n      onDragStart,\n      onDragEnd,\n      onMouseOver,\n      onMouseOut\n    } = props,\n    markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n  const {\n    position,\n    draggable\n  } = markerOptions;\n  // create marker instance and add to the map once the map is available\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!map) {\n      if (map === undefined) console.error('<Marker> has to be inside a Map component.');\n      return;\n    }\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map]);\n  // attach and re-attach event-handlers when any of the properties change\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    const m = marker;\n    // Add event listeners\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n    marker.setDraggable(Boolean(draggable));\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut]);\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n  // update position when changed\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n  return marker;\n}\n/**\n * Component to render a Google Maps Marker on a map\n */\nconst Marker = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n  const marker = useMarker(props);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => marker, [marker]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null);\n});\nfunction useMarkerRef() {\n  const [marker, setMarker] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const refCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\n/**\n * Component to render a google maps marker Pin View\n */\nconst Pin = props => {\n  var _useContext;\n  const advancedMarker = (_useContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n  const glyphContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => document.createElement('div'), []);\n  // Create Pin View instance\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n      }\n      return;\n    }\n    if (props.glyph && props.children) {\n      logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n    }\n    if (react__WEBPACK_IMPORTED_MODULE_0__.Children.count(props.children) > 1) {\n      logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n    }\n    const pinViewOptions = _extends({}, props);\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, glyphContainer, props]);\n  return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(props.children, glyphContainer);\n};\n\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = zoom => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = ({\n  viewState\n}) => {\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n  return _extends({}, viewState, {\n    fovy: 25,\n    pitch: Math.min(maxTilt, pitch)\n  });\n};\n\n\n//# sourceMappingURL=index.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxSztBQUM1SDtBQUNDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixnREFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0NBQVEsR0FBRztBQUNyRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEMsOENBQThDLGlEQUFVO0FBQ3hELHNCQUFzQjtBQUN0QjtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUCwwQkFBMEIsOENBQU87QUFDakMsMkJBQTJCLDhDQUFPO0FBQ2xDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1QkFBdUIsOENBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZDQUFNO0FBQ3BCLHVCQUF1Qiw0Q0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGlEQUFVO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0EsR0FBRyxlQUFlLGdEQUFtQixpREFBaUQsZ0RBQW1CLHNJQUFzSSxnREFBbUI7QUFDbFE7O0FBRUE7QUFDQSxzQkFBc0IsK0NBQVE7QUFDOUIsY0FBYyxrREFBVztBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlEQUFVO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZDQUFNO0FBQ2pDO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsZ0RBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0IsaURBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLHNEQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILHdCQUF3Qiw4Q0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsOENBQU87QUFDOUI7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsZ0RBQW1CO0FBQzNDO0FBQ0E7QUFDQSxPQUFPLGlCQUFpQjtBQUN4QjtBQUNBLEtBQUssZUFBZSxnREFBbUI7QUFDdkM7QUFDQSxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSSxJQUFJLHNCQUFzQixnREFBbUI7QUFDakQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpREFBVTtBQUN4QixFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGdEQUFtQjtBQUNqRDtBQUNBO0FBQ0EsOEJBQThCLCtDQUFRO0FBQ3RDLGtEQUFrRCwrQ0FBUTtBQUMxRCw2QkFBNkIsaURBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLDJDQUFRO0FBQzVCO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFVO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxxQ0FBcUMsOENBQU87QUFDNUM7QUFDQSxJQUFJO0FBQ0osRUFBRSwwREFBbUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBLEdBQUcsK0JBQStCLHVEQUFZO0FBQzlDLENBQUM7QUFDRDtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QyxzQkFBc0Isa0RBQVc7QUFDakM7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkJBQTZCLGlEQUFVO0FBQ3ZDLHdCQUF3Qiw2Q0FBTTtBQUM5QixrREFBa0QsK0NBQVE7QUFDMUQ7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLGdEQUFtQixDQUFDLDJDQUFjLHFDQUFxQyx1REFBWTtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQVU7QUFDeEI7QUFDQTtBQUNBLElBQUksRUFBRSxpREFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwyQkFBMkIsOENBQU87QUFDbEM7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyx1REFBWTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEMsNkJBQTZCLGlEQUFVO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBVTtBQUN6QjtBQUNBLEVBQUUsMERBQW1CO0FBQ3JCLHNCQUFzQixnREFBbUIsQ0FBQywyQ0FBYztBQUN4RCxDQUFDO0FBQ0Q7QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEMsc0JBQXNCLGtEQUFXO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpREFBVTtBQUNsRCx5QkFBeUIsOENBQU87QUFDaEM7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBUTtBQUNoQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUyx1REFBWTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRW1WO0FBQ25WIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcm9vZi1tZWRpY3MvLi9ub2RlX21vZHVsZXMvQHZpcy5nbC9yZWFjdC1nb29nbGUtbWFwcy9kaXN0L2luZGV4Lm1vZGVybi5tanM/ZGRjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlU3RhdGUsIHVzZVJlZHVjZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlTGF5b3V0RWZmZWN0LCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgaXNEZWVwRXF1YWwgZnJvbSAnZmFzdC1kZWVwLWVxdWFsJztcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3QgQVBJTG9hZGluZ1N0YXR1cyA9IHtcbiAgTk9UX0xPQURFRDogJ05PVF9MT0FERUQnLFxuICBMT0FESU5HOiAnTE9BRElORycsXG4gIExPQURFRDogJ0xPQURFRCcsXG4gIEZBSUxFRDogJ0ZBSUxFRCcsXG4gIEFVVEhfRkFJTFVSRTogJ0FVVEhfRkFJTFVSRSdcbn07XG5cbmNvbnN0IE1BUFNfQVBJX0JBU0VfVVJMID0gJ2h0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcyc7XG4vKipcbiAqIEEgR29vZ2xlTWFwc0FwaUxvYWRlciB0byByZWxpYWJseSBsb2FkIGFuZCB1bmxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLlxuICpcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBhbmQgdW5sb2FkaW5nIGlzIGRlbGF5ZWQgaW50byB0aGUgbWljcm90YXNrIHF1ZXVlLCB0b1xuICogYWxsb3cgdXNpbmcgdGhlIEFQSSBpbiBhbiB1c2VFZmZlY3QgaG9vaywgd2l0aG91dCB3b3JyeWluZyBhYm91dCBtdWx0aXBsZSBBUEkgbG9hZHMuXG4gKi9cbmNsYXNzIEdvb2dsZU1hcHNBcGlMb2FkZXIge1xuICAvKipcbiAgICogTG9hZHMgdGhlIEdvb2dsZSBNYXBzIEFQSSB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICogU2luY2UgdGhlIE1hcHMgbGlicmFyeSBjYW4gb25seSBiZSBsb2FkZWQgb25jZSBwZXIgcGFnZSwgdGhpcyB3aWxsXG4gICAqIHByb2R1Y2UgYSB3YXJuaW5nIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50XG4gICAqIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIHJlc29sdmVzIHdoZW4gbG9hZGluZyBjb21wbGV0ZXNcbiAgICogYW5kIHJlamVjdHMgaW4gY2FzZSBvZiBhbiBlcnJvciBvciB3aGVuIHRoZSBsb2FkaW5nIHdhcyBhYm9ydGVkLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGxvYWQocGFyYW1zLCBvbkxvYWRpbmdTdGF0dXNDaGFuZ2UpIHtcbiAgICB2YXIgX3dpbmRvdyRnb29nbGU7XG4gICAgY29uc3QgbGlicmFyaWVzID0gcGFyYW1zLmxpYnJhcmllcyA/IHBhcmFtcy5saWJyYXJpZXMuc3BsaXQoJywnKSA6IFtdO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB0aGlzLnNlcmlhbGl6ZVBhcmFtcyhwYXJhbXMpO1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gob25Mb2FkaW5nU3RhdHVzQ2hhbmdlKTtcbiAgICAvLyBOb3RlOiBpZiBgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeWAgaGFzIGJlZW4gZGVmaW5lZCBleHRlcm5hbGx5LCB3ZVxuICAgIC8vICAgYXNzdW1lIHRoYXQgbG9hZGluZyBpcyBjb21wbGV0ZSBhbmQgc3VjY2Vzc2Z1bC5cbiAgICAvLyAgIElmIGl0IHdhcyBkZWZpbmVkIGJ5IGEgcHJldmlvdXMgY2FsbCB0byB0aGlzIG1ldGhvZCwgYSB3YXJuaW5nXG4gICAgLy8gICBtZXNzYWdlIGlzIGxvZ2dlZCBpZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgaW4gYXBpLXBhcmFtZXRlcnMgdXNlZFxuICAgIC8vICAgZm9yIGJvdGggY2FsbHMuXG4gICAgaWYgKChfd2luZG93JGdvb2dsZSA9IHdpbmRvdy5nb29nbGUpICE9IG51bGwgJiYgKF93aW5kb3ckZ29vZ2xlID0gX3dpbmRvdyRnb29nbGUubWFwcykgIT0gbnVsbCAmJiBfd2luZG93JGdvb2dsZS5pbXBvcnRMaWJyYXJ5KSB7XG4gICAgICAvLyBubyBzZXJpYWxpemVkIHBhcmFtZXRlcnMgbWVhbnMgaXQgd2FzIGxvYWRlZCBleHRlcm5hbGx5XG4gICAgICBpZiAoIXRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcykge1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbiAgICAgIH1cbiAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlcmlhbGl6ZWRBcGlQYXJhbXMgPSBzZXJpYWxpemVkUGFyYW1zO1xuICAgICAgdGhpcy5pbml0SW1wb3J0TGlicmFyeShwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZXJpYWxpemVkQXBpUGFyYW1zICYmIHRoaXMuc2VyaWFsaXplZEFwaVBhcmFtcyAhPT0gc2VyaWFsaXplZFBhcmFtcykge1xuICAgICAgY29uc29sZS53YXJuKGBbZ29vZ2xlLW1hcHMtYXBpLWxvYWRlcl0gVGhlIG1hcHMgQVBJIGhhcyBhbHJlYWR5IGJlZW4gbG9hZGVkIGAgKyBgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyBhbmQgd2lsbCBub3QgYmUgbG9hZGVkIGFnYWluLiBSZWZyZXNoIHRoZSBgICsgYHBhZ2UgZm9yIG5ldyB2YWx1ZXMgdG8gaGF2ZSBlZmZlY3QuYCk7XG4gICAgfVxuICAgIGNvbnN0IGxpYnJhcmllc1RvTG9hZCA9IFsnbWFwcycsIC4uLmxpYnJhcmllc107XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwobGlicmFyaWVzVG9Mb2FkLm1hcChuYW1lID0+IGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSkpKTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBwYXJhbXRlcnMgdXNlZCB0byBsb2FkIHRoZSBsaWJyYXJ5IGZvciBlYXNpZXIgY29tcGFyaXNvbi5cbiAgICovXG4gIHN0YXRpYyBzZXJpYWxpemVQYXJhbXMocGFyYW1zKSB7XG4gICAgcmV0dXJuIFtwYXJhbXMudiwgcGFyYW1zLmtleSwgcGFyYW1zLmxhbmd1YWdlLCBwYXJhbXMucmVnaW9uLCBwYXJhbXMuYXV0aFJlZmVycmVyUG9saWN5LCBwYXJhbXMuc29sdXRpb25DaGFubmVsXS5qb2luKCcvJyk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdsb2JhbCBgZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeWAgZnVuY3Rpb24gZm9yIGJvb3RzdHJhcHBpbmcuXG4gICAqIFRoaXMgaXMgZXNzZW50aWFsbHkgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZHluYW1pYyBsb2FkaW5nIHNjcmlwdFxuICAgKiBmcm9tIHRoZSBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIHdpdGggc29tZSBtaW5vciBhZGp1c3RtZW50cy5cbiAgICpcbiAgICogVGhlIGNyZWF0ZWQgaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB3aWxsIGxvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJLFxuICAgKiB3aGljaCB3aWxsIHRoZW4gcmVwbGFjZSB0aGUgYGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnlgIGZ1bmN0aW9uIHdpdGggdGhlIGZ1bGxcbiAgICogaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvbG9hZC1tYXBzLWpzLWFwaSNkeW5hbWljLWxpYnJhcnktaW1wb3J0XG4gICAqL1xuICBzdGF0aWMgaW5pdEltcG9ydExpYnJhcnkocGFyYW1zKSB7XG4gICAgaWYgKCF3aW5kb3cuZ29vZ2xlKSB3aW5kb3cuZ29vZ2xlID0ge307XG4gICAgaWYgKCF3aW5kb3cuZ29vZ2xlLm1hcHMpIHdpbmRvdy5nb29nbGUubWFwcyA9IHt9O1xuICAgIGlmICh3aW5kb3cuZ29vZ2xlLm1hcHNbJ2ltcG9ydExpYnJhcnknXSkge1xuICAgICAgY29uc29sZS5lcnJvcignW2dvb2dsZS1tYXBzLWFwaS1sb2FkZXItaW50ZXJuYWxdOiBpbml0SW1wb3J0TGlicmFyeSBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFwaVByb21pc2UgPSBudWxsO1xuICAgIGNvbnN0IGxvYWRBcGkgPSAoKSA9PiB7XG4gICAgICBpZiAoYXBpUHJvbWlzZSkgcmV0dXJuIGFwaVByb21pc2U7XG4gICAgICBhcGlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB2YXIgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0O1xuICAgICAgICBjb25zdCBzY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgIGNvbnN0IHVybFBhcmFtTmFtZSA9IGtleS5yZXBsYWNlKC9bQS1aXS9nLCB0ID0+ICdfJyArIHRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgdXJsUGFyYW1zLnNldCh1cmxQYXJhbU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB1cmxQYXJhbXMuc2V0KCdsb2FkaW5nJywgJ2FzeW5jJyk7XG4gICAgICAgIHVybFBhcmFtcy5zZXQoJ2NhbGxiYWNrJywgJ19fZ29vZ2xlTWFwc0NhbGxiYWNrX18nKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdEVsZW1lbnQuc3JjID0gTUFQU19BUElfQkFTRV9VUkwgKyBgP2AgKyB1cmxQYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgc2NyaXB0RWxlbWVudC5ub25jZSA9ICgoX2RvY3VtZW50JHF1ZXJ5U2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W25vbmNlXScpKSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50JHF1ZXJ5U2VsZWN0Lm5vbmNlKSB8fCAnJztcbiAgICAgICAgc2NyaXB0RWxlbWVudC5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuRkFJTEVEO1xuICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBjb3VsZCBub3QgbG9hZC4nKSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5fX2dvb2dsZU1hcHNDYWxsYmFja19fID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuTE9BREVEO1xuICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmdtX2F1dGhGYWlsdXJlID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXR1cyA9IEFQSUxvYWRpbmdTdGF0dXMuQVVUSF9GQUlMVVJFO1xuICAgICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLkxPQURJTkc7XG4gICAgICAgIHRoaXMubm90aWZ5TG9hZGluZ1N0YXR1c0xpc3RlbmVycygpO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZChzY3JpcHRFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFwaVByb21pc2U7XG4gICAgfTtcbiAgICAvLyBmb3IgdGhlIGZpcnN0IGxvYWQsIHdlIGRlY2xhcmUgYW4gaW1wb3J0TGlicmFyeSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAgICAvLyBiZSBvdmVyd3JpdHRlbiBvbmNlIHRoZSBhcGkgaXMgbG9hZGVkLlxuICAgIGdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkgPSBsaWJyYXJ5TmFtZSA9PiBsb2FkQXBpKCkudGhlbigoKSA9PiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KGxpYnJhcnlOYW1lKSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIGFsbCByZWdpc3RlcmVkIGxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMgYWZ0ZXIgYSBzdGF0dXMgdXBkYXRlLlxuICAgKi9cbiAgc3RhdGljIG5vdGlmeUxvYWRpbmdTdGF0dXNMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgZm4odGhpcy5sb2FkaW5nU3RhdHVzKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogVGhlIGN1cnJlbnQgbG9hZGluZ1N0YXR1cyBvZiB0aGUgQVBJLlxuICovXG5Hb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMgPSBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG4vKipcbiAqIFRoZSBwYXJhbWV0ZXJzIHVzZWQgZm9yIGZpcnN0IGxvYWRpbmcgdGhlIEFQSS5cbiAqL1xuR29vZ2xlTWFwc0FwaUxvYWRlci5zZXJpYWxpemVkQXBpUGFyYW1zID0gdm9pZCAwO1xuLyoqXG4gKiBBIGxpc3Qgb2YgZnVuY3Rpb25zIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGxvYWRpbmcgc3RhdHVzIGNoYW5nZXMuXG4gKi9cbkdvb2dsZU1hcHNBcGlMb2FkZXIubGlzdGVuZXJzID0gW107XG5cbmNvbnN0IF9leGNsdWRlZCQzID0gW1wib25Mb2FkXCIsIFwiYXBpS2V5XCIsIFwidmVyc2lvblwiLCBcImxpYnJhcmllc1wiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuY29uc3QgQVBJUHJvdmlkZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxuICogbG9jYWwgaG9vayB0byBzZXQgdXAgdGhlIG1hcC1pbnN0YW5jZSBtYW5hZ2VtZW50IGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlcygpIHtcbiAgY29uc3QgW21hcEluc3RhbmNlcywgc2V0TWFwSW5zdGFuY2VzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgYWRkTWFwSW5zdGFuY2UgPSAobWFwSW5zdGFuY2UsIGlkID0gJ2RlZmF1bHQnKSA9PiB7XG4gICAgc2V0TWFwSW5zdGFuY2VzKGluc3RhbmNlcyA9PiBfZXh0ZW5kcyh7fSwgaW5zdGFuY2VzLCB7XG4gICAgICBbaWRdOiBtYXBJbnN0YW5jZVxuICAgIH0pKTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlTWFwSW5zdGFuY2UgPSAoaWQgPSAnZGVmYXVsdCcpID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgc2V0TWFwSW5zdGFuY2VzKF9yZWYgPT4ge1xuICAgICAgbGV0IHJlbWFpbmluZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtpZF0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBjbGVhck1hcEluc3RhbmNlcyA9ICgpID0+IHtcbiAgICBzZXRNYXBJbnN0YW5jZXMoe30pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1hcEluc3RhbmNlcyxcbiAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICByZW1vdmVNYXBJbnN0YW5jZSxcbiAgICBjbGVhck1hcEluc3RhbmNlc1xuICB9O1xufVxuLyoqXG4gKiBsb2NhbCBob29rIHRvIGhhbmRsZSB0aGUgbG9hZGluZyBvZiB0aGUgbWFwcyBBUEksIHJldHVybnMgdGhlIGN1cnJlbnQgbG9hZGluZyBzdGF0dXNcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5mdW5jdGlvbiB1c2VHb29nbGVNYXBzQXBpTG9hZGVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICAgIG9uTG9hZCxcbiAgICAgIGFwaUtleSxcbiAgICAgIHZlcnNpb24sXG4gICAgICBsaWJyYXJpZXMgPSBbXVxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlckFwaVBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMyk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShHb29nbGVNYXBzQXBpTG9hZGVyLmxvYWRpbmdTdGF0dXMpO1xuICBjb25zdCBbbG9hZGVkTGlicmFyaWVzLCBhZGRMb2FkZWRMaWJyYXJ5XSA9IHVzZVJlZHVjZXIoKGxvYWRlZExpYnJhcmllcywgYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2FkZWRMaWJyYXJpZXMsIHtcbiAgICAgIFthY3Rpb24ubmFtZV06IGFjdGlvbi52YWx1ZVxuICAgIH0pO1xuICB9LCB7fSk7XG4gIGNvbnN0IGxpYnJhcmllc1N0cmluZyA9IHVzZU1lbW8oKCkgPT4gbGlicmFyaWVzID09IG51bGwgPyB2b2lkIDAgOiBsaWJyYXJpZXMuam9pbignLCcpLCBbbGlicmFyaWVzXSk7XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXJhbXMgPSB1c2VNZW1vKCgpID0+IEpTT04uc3RyaW5naWZ5KF9leHRlbmRzKHtcbiAgICBhcGlLZXksXG4gICAgdmVyc2lvblxuICB9LCBvdGhlckFwaVBhcmFtcykpLCBbYXBpS2V5LCB2ZXJzaW9uLCBvdGhlckFwaVBhcmFtc10pO1xuICBjb25zdCBpbXBvcnRMaWJyYXJ5ID0gdXNlQ2FsbGJhY2soYXN5bmMgbmFtZSA9PiB7XG4gICAgdmFyIF9nb29nbGU7XG4gICAgaWYgKGxvYWRlZExpYnJhcmllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIGxvYWRlZExpYnJhcmllc1tuYW1lXTtcbiAgICB9XG4gICAgaWYgKCEoKF9nb29nbGUgPSBnb29nbGUpICE9IG51bGwgJiYgKF9nb29nbGUgPSBfZ29vZ2xlLm1hcHMpICE9IG51bGwgJiYgX2dvb2dsZS5pbXBvcnRMaWJyYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbYXBpLXByb3ZpZGVyLWludGVybmFsXSBpbXBvcnRMaWJyYXJ5IHdhcyBjYWxsZWQgYmVmb3JlICcgKyAnZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeSB3YXMgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gYXdhaXQgd2luZG93Lmdvb2dsZS5tYXBzLmltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgYWRkTG9hZGVkTGlicmFyeSh7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWU6IHJlc1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH0sIFtsb2FkZWRMaWJyYXJpZXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gX2V4dGVuZHMoe1xuICAgICAgICAgIGtleTogYXBpS2V5XG4gICAgICAgIH0sIG90aGVyQXBpUGFyYW1zKTtcbiAgICAgICAgaWYgKHZlcnNpb24pIHBhcmFtcy52ID0gdmVyc2lvbjtcbiAgICAgICAgaWYgKChsaWJyYXJpZXNTdHJpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IGxpYnJhcmllc1N0cmluZy5sZW5ndGgpID4gMCkgcGFyYW1zLmxpYnJhcmllcyA9IGxpYnJhcmllc1N0cmluZztcbiAgICAgICAgYXdhaXQgR29vZ2xlTWFwc0FwaUxvYWRlci5sb2FkKHBhcmFtcywgc3RhdHVzID0+IHNldFN0YXR1cyhzdGF0dXMpKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFsnY29yZScsICdtYXBzJywgLi4ubGlicmFyaWVzXSkge1xuICAgICAgICAgIGF3YWl0IGltcG9ydExpYnJhcnkobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgIG9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCc8QXBpUHJvdmlkZXI+IGZhaWxlZCB0byBsb2FkIEdvb2dsZSBNYXBzIEFQSScsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFthcGlLZXksIGxpYnJhcmllc1N0cmluZywgc2VyaWFsaXplZFBhcmFtc10pO1xuICByZXR1cm4ge1xuICAgIHN0YXR1cyxcbiAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgaW1wb3J0TGlicmFyeVxuICB9O1xufVxuLyoqXG4gKiBDb21wb25lbnQgdG8gd3JhcCB0aGUgR29vZ2xlIE1hcHMgUmVhY3QgY29tcG9uZW50cyBhbmQgbG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcbiAqL1xuY29uc3QgQVBJUHJvdmlkZXIgPSBwcm9wcyA9PiB7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHByb3BzLFxuICAgIGxvYWRlclByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZDIpO1xuICBjb25zdCB7XG4gICAgbWFwSW5zdGFuY2VzLFxuICAgIGFkZE1hcEluc3RhbmNlLFxuICAgIHJlbW92ZU1hcEluc3RhbmNlLFxuICAgIGNsZWFyTWFwSW5zdGFuY2VzXG4gIH0gPSB1c2VNYXBJbnN0YW5jZXMoKTtcbiAgY29uc3Qge1xuICAgIHN0YXR1cyxcbiAgICBsb2FkZWRMaWJyYXJpZXMsXG4gICAgaW1wb3J0TGlicmFyeVxuICB9ID0gdXNlR29vZ2xlTWFwc0FwaUxvYWRlcihsb2FkZXJQcm9wcyk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBtYXBJbnN0YW5jZXMsXG4gICAgYWRkTWFwSW5zdGFuY2UsXG4gICAgcmVtb3ZlTWFwSW5zdGFuY2UsXG4gICAgY2xlYXJNYXBJbnN0YW5jZXMsXG4gICAgc3RhdHVzLFxuICAgIGxvYWRlZExpYnJhcmllcyxcbiAgICBpbXBvcnRMaWJyYXJ5XG4gIH0pLCBbbWFwSW5zdGFuY2VzLCBhZGRNYXBJbnN0YW5jZSwgcmVtb3ZlTWFwSW5zdGFuY2UsIGNsZWFyTWFwSW5zdGFuY2VzLCBzdGF0dXMsIGxvYWRlZExpYnJhcmllcywgaW1wb3J0TGlicmFyeV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQVBJUHJvdmlkZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgZWZmZWN0cyB0byBiaW5kIGV2ZW50LWhhbmRsZXJzIGZvciBhbGwgZXZlbnQtcHJvcHMgaW4gTWFwRXZlbnRQcm9wcy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VNYXBFdmVudHMobWFwLCBwcm9wcykge1xuICAvLyBub3RlOiBjYWxsaW5nIGEgdXNlRWZmZWN0IGhvb2sgZnJvbSB3aXRoaW4gYSBsb29wIGlzIHByb2hpYml0ZWQgYnkgdGhlXG4gIC8vIHJ1bGVzIG9mIGhvb2tzLCBidXQgaXQncyBvayBoZXJlIHNpbmNlIGl0J3MgdW5jb25kaXRpb25hbCBhbmQgdGhlIG51bWJlclxuICAvLyBhbmQgb3JkZXIgb2YgaXRlcmF0aW9ucyBpcyBhbHdheXMgc3RyaWN0bHkgdGhlIHNhbWUuXG4gIC8vIChzZWUgaHR0cHM6Ly9sZWdhY3kucmVhY3Rqcy5vcmcvZG9jcy9ob29rcy1ydWxlcy5odG1sKVxuICBmb3IgKGNvbnN0IHByb3BOYW1lIG9mIGV2ZW50UHJvcE5hbWVzKSB7XG4gICAgLy8gZml4bWU6IHRoaXMgY2FzdCBpcyBlc3NlbnRpYWxseSBhICd0cnVzdCBtZSwgYnJvJyBmb3IgdHlwZXNjcmlwdCwgYnV0XG4gICAgLy8gICBhIHByb3BlciBzb2x1dGlvbiBzZWVtcyB3YXkgdG9vIGNvbXBsaWNhdGVkIHJpZ2h0IG5vd1xuICAgIGNvbnN0IGhhbmRsZXIgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgY29uc3QgZXZlbnRUeXBlID0gcHJvcE5hbWVUb0V2ZW50VHlwZVtwcm9wTmFtZV07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgICBpZiAoIWhhbmRsZXIpIHJldHVybjtcbiAgICAgIGNvbnN0IGxpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCBldmVudFR5cGUsIGV2ID0+IHtcbiAgICAgICAgaGFuZGxlcihjcmVhdGVNYXBFdmVudChldmVudFR5cGUsIG1hcCwgZXYpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICAgIH0sIFttYXAsIGV2ZW50VHlwZSwgaGFuZGxlcl0pO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgd3JhcHBlZCBtYXAtZXZlbnRzIHVzZWQgZm9yIHRoZSBldmVudC1wcm9wcy5cbiAqIEBwYXJhbSB0eXBlIHRoZSBldmVudCB0eXBlIGFzIGl0IGlzIHNwZWNpZmllZCB0byB0aGUgbWFwcyBhcGlcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZSB0aGUgZXZlbnQgb3JpZ2luYXRlcyBmcm9tXG4gKiBAcGFyYW0gc3JjRXZlbnQgdGhlIHNvdXJjZS1ldmVudCBpZiB0aGVyZSBpcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1hcEV2ZW50KHR5cGUsIG1hcCwgc3JjRXZlbnQpIHtcbiAgY29uc3QgZXYgPSB7XG4gICAgdHlwZSxcbiAgICBtYXAsXG4gICAgZGV0YWlsOiB7fSxcbiAgICBzdG9wcGFibGU6IGZhbHNlLFxuICAgIHN0b3A6ICgpID0+IHt9XG4gIH07XG4gIGlmIChjYW1lcmFFdmVudFR5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgY29uc3QgY2FtRXZlbnQgPSBldjtcbiAgICBjb25zdCBjZW50ZXIgPSBtYXAuZ2V0Q2VudGVyKCk7XG4gICAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgY29uc3QgaGVhZGluZyA9IG1hcC5nZXRIZWFkaW5nKCkgfHwgMDtcbiAgICBjb25zdCB0aWx0ID0gbWFwLmdldFRpbHQoKSB8fCAwO1xuICAgIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICBpZiAoIWNlbnRlciB8fCAhYm91bmRzIHx8ICFOdW1iZXIuaXNGaW5pdGUoem9vbSkpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUV2ZW50XSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gICAgfVxuICAgIGNhbUV2ZW50LmRldGFpbCA9IHtcbiAgICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICAgIGxhdDogMCxcbiAgICAgICAgbG5nOiAwXG4gICAgICB9LFxuICAgICAgem9vbTogem9vbSB8fCAwLFxuICAgICAgaGVhZGluZzogaGVhZGluZyxcbiAgICAgIHRpbHQ6IHRpbHQsXG4gICAgICBib3VuZHM6IChib3VuZHMgPT0gbnVsbCA/IHZvaWQgMCA6IGJvdW5kcy50b0pTT04oKSkgfHwge1xuICAgICAgICBub3J0aDogOTAsXG4gICAgICAgIGVhc3Q6IDE4MCxcbiAgICAgICAgc291dGg6IC05MCxcbiAgICAgICAgd2VzdDogLTE4MFxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNhbUV2ZW50O1xuICB9IGVsc2UgaWYgKG1vdXNlRXZlbnRUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHZhciBfc3JjRXZlbnQkbGF0TG5nO1xuICAgIGlmICghc3JjRXZlbnQpIHRocm93IG5ldyBFcnJvcignW2NyZWF0ZUV2ZW50XSBtb3VzZSBldmVudHMgbXVzdCBwcm92aWRlIGEgc3JjRXZlbnQnKTtcbiAgICBjb25zdCBtb3VzZUV2ZW50ID0gZXY7XG4gICAgbW91c2VFdmVudC5kb21FdmVudCA9IHNyY0V2ZW50LmRvbUV2ZW50O1xuICAgIG1vdXNlRXZlbnQuc3RvcHBhYmxlID0gdHJ1ZTtcbiAgICBtb3VzZUV2ZW50LnN0b3AgPSAoKSA9PiBzcmNFdmVudC5zdG9wKCk7XG4gICAgbW91c2VFdmVudC5kZXRhaWwgPSB7XG4gICAgICBsYXRMbmc6ICgoX3NyY0V2ZW50JGxhdExuZyA9IHNyY0V2ZW50LmxhdExuZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zcmNFdmVudCRsYXRMbmcudG9KU09OKCkpIHx8IG51bGwsXG4gICAgICBwbGFjZUlkOiBzcmNFdmVudC5wbGFjZUlkXG4gICAgfTtcbiAgICByZXR1cm4gbW91c2VFdmVudDtcbiAgfVxuICByZXR1cm4gZXY7XG59XG4vKipcbiAqIG1hcHMgdGhlIGNhbWVsQ2FzZWQgbmFtZXMgb2YgZXZlbnQtcHJvcHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnQtdHlwZXNcbiAqIHVzZWQgaW4gdGhlIG1hcHMgQVBJLlxuICovXG5jb25zdCBwcm9wTmFtZVRvRXZlbnRUeXBlID0ge1xuICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgb25DbGljazogJ2NsaWNrJyxcbiAgb25Db250ZXh0bWVudTogJ2NvbnRleHRtZW51JyxcbiAgb25EYmxjbGljazogJ2RibGNsaWNrJyxcbiAgb25EcmFnOiAnZHJhZycsXG4gIG9uRHJhZ2VuZDogJ2RyYWdlbmQnLFxuICBvbkRyYWdzdGFydDogJ2RyYWdzdGFydCcsXG4gIG9uSGVhZGluZ0NoYW5nZWQ6ICdoZWFkaW5nX2NoYW5nZWQnLFxuICBvbklkbGU6ICdpZGxlJyxcbiAgb25Jc0ZyYWN0aW9uYWxab29tRW5hYmxlZENoYW5nZWQ6ICdpc2ZyYWN0aW9uYWx6b29tZW5hYmxlZF9jaGFuZ2VkJyxcbiAgb25NYXBDYXBhYmlsaXRpZXNDaGFuZ2VkOiAnbWFwY2FwYWJpbGl0aWVzX2NoYW5nZWQnLFxuICBvbk1hcFR5cGVJZENoYW5nZWQ6ICdtYXB0eXBlaWRfY2hhbmdlZCcsXG4gIG9uTW91c2Vtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgb25Nb3VzZW91dDogJ21vdXNlb3V0JyxcbiAgb25Nb3VzZW92ZXI6ICdtb3VzZW92ZXInLFxuICBvblByb2plY3Rpb25DaGFuZ2VkOiAncHJvamVjdGlvbl9jaGFuZ2VkJyxcbiAgb25SZW5kZXJpbmdUeXBlQ2hhbmdlZDogJ3JlbmRlcmluZ3R5cGVfY2hhbmdlZCcsXG4gIG9uVGlsZXNMb2FkZWQ6ICd0aWxlc2xvYWRlZCcsXG4gIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICBvblpvb21DaGFuZ2VkOiAnem9vbV9jaGFuZ2VkJyxcbiAgLy8gbm90ZTogb25DYW1lcmFDaGFuZ2VkIGlzIGFuIGFsaWFzIGZvciB0aGUgYm91bmRzX2NoYW5nZWQgZXZlbnQsXG4gIC8vIHNpbmNlIHRoYXQgaXMgZ29pbmcgdG8gYmUgZmlyZWQgaW4gZXZlcnkgc2l0dWF0aW9uIHdoZXJlIHRoZSBjYW1lcmEgaXNcbiAgLy8gdXBkYXRlZC5cbiAgb25DYW1lcmFDaGFuZ2VkOiAnYm91bmRzX2NoYW5nZWQnXG59O1xuY29uc3QgY2FtZXJhRXZlbnRUeXBlcyA9IFsnYm91bmRzX2NoYW5nZWQnLCAnY2VudGVyX2NoYW5nZWQnLCAnaGVhZGluZ19jaGFuZ2VkJywgJ3Byb2plY3Rpb25fY2hhbmdlZCcsICd0aWx0X2NoYW5nZWQnLCAnem9vbV9jaGFuZ2VkJ107XG5jb25zdCBtb3VzZUV2ZW50VHlwZXMgPSBbJ2NsaWNrJywgJ2NvbnRleHRtZW51JywgJ2RibGNsaWNrJywgJ21vdXNlbW92ZScsICdtb3VzZW91dCcsICdtb3VzZW92ZXInXTtcbmNvbnN0IGV2ZW50UHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcE5hbWVUb0V2ZW50VHlwZSk7XG5cbmZ1bmN0aW9uIHVzZURlZXBDb21wYXJlRWZmZWN0KGVmZmVjdCwgZGVwcykge1xuICBjb25zdCByZWYgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgaWYgKCFyZWYuY3VycmVudCB8fCAhaXNEZWVwRXF1YWwoZGVwcywgcmVmLmN1cnJlbnQpKSB7XG4gICAgcmVmLmN1cnJlbnQgPSBkZXBzO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgdXNlRWZmZWN0KGVmZmVjdCwgcmVmLmN1cnJlbnQpO1xufVxuXG5jb25zdCBtYXBPcHRpb25LZXlzID0gbmV3IFNldChbJ2JhY2tncm91bmRDb2xvcicsICdjbGlja2FibGVJY29ucycsICdjb250cm9sU2l6ZScsICdkaXNhYmxlRGVmYXVsdFVJJywgJ2Rpc2FibGVEb3VibGVDbGlja1pvb20nLCAnZHJhZ2dhYmxlJywgJ2RyYWdnYWJsZUN1cnNvcicsICdkcmFnZ2luZ0N1cnNvcicsICdmdWxsc2NyZWVuQ29udHJvbCcsICdmdWxsc2NyZWVuQ29udHJvbE9wdGlvbnMnLCAnZ2VzdHVyZUhhbmRsaW5nJywgJ2lzRnJhY3Rpb25hbFpvb21FbmFibGVkJywgJ2tleWJvYXJkU2hvcnRjdXRzJywgJ21hcFR5cGVDb250cm9sJywgJ21hcFR5cGVDb250cm9sT3B0aW9ucycsICdtYXBUeXBlSWQnLCAnbWF4Wm9vbScsICdtaW5ab29tJywgJ25vQ2xlYXInLCAncGFuQ29udHJvbCcsICdwYW5Db250cm9sT3B0aW9ucycsICdyZXN0cmljdGlvbicsICdyb3RhdGVDb250cm9sJywgJ3JvdGF0ZUNvbnRyb2xPcHRpb25zJywgJ3NjYWxlQ29udHJvbCcsICdzY2FsZUNvbnRyb2xPcHRpb25zJywgJ3Njcm9sbHdoZWVsJywgJ3N0cmVldFZpZXcnLCAnc3RyZWV0Vmlld0NvbnRyb2wnLCAnc3RyZWV0Vmlld0NvbnRyb2xPcHRpb25zJywgJ3N0eWxlcycsICd6b29tQ29udHJvbCcsICd6b29tQ29udHJvbE9wdGlvbnMnXSk7XG4vKipcbiAqIEludGVybmFsIGhvb2sgdG8gdXBkYXRlIHRoZSBtYXAtb3B0aW9ucyB3aGVuIHByb3BzIGFyZSBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBtYXAgdGhlIG1hcCBpbnN0YW5jZVxuICogQHBhcmFtIG1hcFByb3BzIHRoZSBwcm9wcyB0byB1cGRhdGUgdGhlIG1hcC1pbnN0YW5jZSB3aXRoXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlTWFwT3B0aW9ucyhtYXAsIG1hcFByb3BzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAtLVxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIGVmZmVjdHMgYXJlbid0IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgY2hhbmdlZC5cbiAgICogSW4gdGhhdCBjYXNlLCB0aGUgdmFsdWVzIHdpbGwgYmUgb3IgaGF2ZSBiZWVuIHBhc3NlZCB0byB0aGUgbWFwXG4gICAqIGNvbnN0cnVjdG9yIHZpYSBtYXBPcHRpb25zLlxuICAgKi9cbiAgY29uc3QgbWFwT3B0aW9ucyA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobWFwUHJvcHMpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKCFtYXBPcHRpb25LZXlzLmhhcyhrZXkpKSBjb250aW51ZTtcbiAgICBtYXBPcHRpb25zW2tleV0gPSBtYXBQcm9wc1trZXldO1xuICB9XG4gIC8vIHVwZGF0ZSB0aGUgbWFwIG9wdGlvbnMgd2hlbiBtYXBPcHRpb25zIGlzIGNoYW5nZWRcbiAgLy8gTm90ZTogZHVlIHRvIHRoZSBkZXN0cnVjdHVyaW5nIGFib3ZlLCBtYXBPcHRpb25zIHdpbGwgYmUgc2VlbiBhcyBjaGFuZ2VkXG4gIC8vICAgd2l0aCBldmVyeSByZS1yZW5kZXIsIHNvIHdlJ3JlIGFzc3VtaW5nIHRoZSBtYXBzLWFwaSB3aWxsIHByb3Blcmx5XG4gIC8vICAgZGVhbCB3aXRoIHVuY2hhbmdlZCBvcHRpb24tdmFsdWVzIHBhc3NlZCBpbnRvIHNldE9wdGlvbnMuXG4gIHVzZURlZXBDb21wYXJlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIG1hcC5zZXRPcHRpb25zKG1hcE9wdGlvbnMpO1xuICB9LCBbbWFwT3B0aW9uc10pO1xuICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwcyAqL1xufVxuXG5mdW5jdGlvbiB1c2VBcGlMb2FkaW5nU3RhdHVzKCkge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIHJldHVybiAoKF91c2VDb250ZXh0ID0gdXNlQ29udGV4dChBUElQcm92aWRlckNvbnRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogX3VzZUNvbnRleHQuc3RhdHVzKSB8fCBBUElMb2FkaW5nU3RhdHVzLk5PVF9MT0FERUQ7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgaG9vayB0aGF0IHVwZGF0ZXMgdGhlIGNhbWVyYSB3aGVuIGRlY2suZ2wgdmlld1N0YXRlIGNoYW5nZXMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlRGVja0dMQ2FtZXJhVXBkYXRlKG1hcCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHZpZXdwb3J0LFxuICAgIHZpZXdTdGF0ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGlzRGVja0dsQ29udHJvbGxlZCA9ICEhdmlld3BvcnQ7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXAgfHwgIXZpZXdTdGF0ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhdGl0dWRlLFxuICAgICAgbG9uZ2l0dWRlLFxuICAgICAgYmVhcmluZzogaGVhZGluZyxcbiAgICAgIHBpdGNoOiB0aWx0LFxuICAgICAgem9vbVxuICAgIH0gPSB2aWV3U3RhdGU7XG4gICAgbWFwLm1vdmVDYW1lcmEoe1xuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGxhdDogbGF0aXR1ZGUsXG4gICAgICAgIGxuZzogbG9uZ2l0dWRlXG4gICAgICB9LFxuICAgICAgaGVhZGluZyxcbiAgICAgIHRpbHQsXG4gICAgICB6b29tOiB6b29tICsgMVxuICAgIH0pO1xuICB9LCBbbWFwLCB2aWV3U3RhdGVdKTtcbiAgcmV0dXJuIGlzRGVja0dsQ29udHJvbGxlZDtcbn1cblxuZnVuY3Rpb24gaXNMYXRMbmdMaXRlcmFsKG9iaikge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAoISgnbGF0JyBpbiBvYmogJiYgJ2xuZycgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG9iai5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShvYmoubG5nKTtcbn1cbmZ1bmN0aW9uIGxhdExuZ0VxdWFscyhhLCBiKSB7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBBID0gdG9MYXRMbmdMaXRlcmFsKGEpO1xuICBjb25zdCBCID0gdG9MYXRMbmdMaXRlcmFsKGIpO1xuICBpZiAoQS5sYXQgIT09IEIubGF0IHx8IEEubG5nICE9PSBCLmxuZykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRvTGF0TG5nTGl0ZXJhbChvYmopIHtcbiAgaWYgKGlzTGF0TG5nTGl0ZXJhbChvYmopKSByZXR1cm4gb2JqO1xuICByZXR1cm4gb2JqLnRvSlNPTigpO1xufVxuXG5mdW5jdGlvbiB1c2VNYXBDYW1lcmFQYXJhbXMobWFwLCBjYW1lcmFTdGF0ZVJlZiwgbWFwUHJvcHMpIHtcbiAgY29uc3QgY2VudGVyID0gbWFwUHJvcHMuY2VudGVyID8gdG9MYXRMbmdMaXRlcmFsKG1hcFByb3BzLmNlbnRlcikgOiBudWxsO1xuICBsZXQgbGF0ID0gbnVsbDtcbiAgbGV0IGxuZyA9IG51bGw7XG4gIGlmIChjZW50ZXIgJiYgTnVtYmVyLmlzRmluaXRlKGNlbnRlci5sYXQpICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubG5nKSkge1xuICAgIGxhdCA9IGNlbnRlci5sYXQ7XG4gICAgbG5nID0gY2VudGVyLmxuZztcbiAgfVxuICBjb25zdCB6b29tID0gTnVtYmVyLmlzRmluaXRlKG1hcFByb3BzLnpvb20pID8gbWFwUHJvcHMuem9vbSA6IG51bGw7XG4gIGNvbnN0IGhlYWRpbmcgPSBOdW1iZXIuaXNGaW5pdGUobWFwUHJvcHMuaGVhZGluZykgPyBtYXBQcm9wcy5oZWFkaW5nIDogbnVsbDtcbiAgY29uc3QgdGlsdCA9IE51bWJlci5pc0Zpbml0ZShtYXBQcm9wcy50aWx0KSA/IG1hcFByb3BzLnRpbHQgOiBudWxsO1xuICAvLyB0aGUgZm9sbG93aW5nIGVmZmVjdCBydW5zIGZvciBldmVyeSByZW5kZXIgb2YgdGhlIG1hcCBjb21wb25lbnQgYW5kIGNoZWNrc1xuICAvLyBpZiB0aGVyZSBhcmUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUga25vd24gc3RhdGUgb2YgdGhlIG1hcCBpbnN0YW5jZVxuICAvLyAoY2FtZXJhU3RhdGVSZWYsIHdoaWNoIGlzIHVwZGF0ZWQgYnkgYWxsIGJvdW5kc19jaGFuZ2VkIGV2ZW50cykgYW5kIHRoZVxuICAvLyBkZXNpcmVkIHN0YXRlIGluIHRoZSBwcm9wcy5cbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRDYW1lcmEgPSB7fTtcbiAgICBsZXQgbmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICBpZiAobGF0ICE9PSBudWxsICYmIGxuZyAhPT0gbnVsbCAmJiAoY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubGF0ICE9PSBsYXQgfHwgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5jZW50ZXIubG5nICE9PSBsbmcpKSB7XG4gICAgICBuZXh0Q2FtZXJhLmNlbnRlciA9IHtcbiAgICAgICAgbGF0LFxuICAgICAgICBsbmdcbiAgICAgIH07XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh6b29tICE9PSBudWxsICYmIGNhbWVyYVN0YXRlUmVmLmN1cnJlbnQuem9vbSAhPT0gem9vbSkge1xuICAgICAgbmV4dENhbWVyYS56b29tID0gem9vbTtcbiAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhlYWRpbmcgIT09IG51bGwgJiYgY2FtZXJhU3RhdGVSZWYuY3VycmVudC5oZWFkaW5nICE9PSBoZWFkaW5nKSB7XG4gICAgICBuZXh0Q2FtZXJhLmhlYWRpbmcgPSBoZWFkaW5nO1xuICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGlsdCAhPT0gbnVsbCAmJiBjYW1lcmFTdGF0ZVJlZi5jdXJyZW50LnRpbHQgIT09IHRpbHQpIHtcbiAgICAgIG5leHRDYW1lcmEudGlsdCA9IHRpbHQ7XG4gICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChuZWVkc1VwZGF0ZSkge1xuICAgICAgbWFwLm1vdmVDYW1lcmEobmV4dENhbWVyYSk7XG4gICAgfVxuICB9KTtcbn1cblxuY29uc3QgQXV0aEZhaWx1cmVNZXNzYWdlID0gKCkgPT4ge1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgekluZGV4OiA5OTksXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhGbG93OiAnY29sdW1uIG5vd3JhcCcsXG4gICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgZm9udFNpemU6ICcuOHJlbScsXG4gICAgY29sb3I6ICdyZ2JhKDAsMCwwLDAuNiknLFxuICAgIGJhY2tncm91bmQ6ICcjZGRkZGRkJyxcbiAgICBwYWRkaW5nOiAnMXJlbSAxLjVyZW0nXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgbnVsbCwgXCJFcnJvcjogQXV0aEZhaWx1cmVcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBcIkEgcHJvYmxlbSB3aXRoIHlvdXIgQVBJIGtleSBwcmV2ZW50cyB0aGUgbWFwIGZyb20gcmVuZGVyaW5nIGNvcnJlY3RseS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgdmFsdWUgb2YgdGhlIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwgbnVsbCwgXCJBUElQcm92aWRlci5hcGlLZXlcIiksIFwiIHByb3AgaXMgY29ycmVjdC4gQ2hlY2sgdGhlIGVycm9yLW1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgZm9yIGZ1cnRoZXIgZGV0YWlscy5cIikpO1xufTtcblxuZnVuY3Rpb24gdXNlQ2FsbGJhY2tSZWYoKSB7XG4gIGNvbnN0IFtlbCwgc2V0RWxdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZiA9IHVzZUNhbGxiYWNrKHZhbHVlID0+IHNldEVsKHZhbHVlKSwgW3NldEVsXSk7XG4gIHJldHVybiBbZWwsIHJlZl07XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiB0aGUgR29vZ2xlIE1hcHMgQVBJIGlzIGxvYWRlZFxuICovXG5mdW5jdGlvbiB1c2VBcGlJc0xvYWRlZCgpIHtcbiAgY29uc3Qgc3RhdHVzID0gdXNlQXBpTG9hZGluZ1N0YXR1cygpO1xuICByZXR1cm4gc3RhdHVzID09PSBBUElMb2FkaW5nU3RhdHVzLkxPQURFRDtcbn1cblxuZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7XG4gIHJldHVybiBmb3JjZVVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQm91bmRzQ2hhbmdlKG1hcCwgcmVmKSB7XG4gIGNvbnN0IGNlbnRlciA9IG1hcC5nZXRDZW50ZXIoKTtcbiAgY29uc3Qgem9vbSA9IG1hcC5nZXRab29tKCk7XG4gIGNvbnN0IGhlYWRpbmcgPSBtYXAuZ2V0SGVhZGluZygpIHx8IDA7XG4gIGNvbnN0IHRpbHQgPSBtYXAuZ2V0VGlsdCgpIHx8IDA7XG4gIGNvbnN0IGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgaWYgKCFjZW50ZXIgfHwgIWJvdW5kcyB8fCAhTnVtYmVyLmlzRmluaXRlKHpvb20pKSB7XG4gICAgY29uc29sZS53YXJuKCdbdXNlVHJhY2tlZENhbWVyYVN0YXRlXSBhdCBsZWFzdCBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBtYXAgJyArICdyZXR1cm5lZCB1bmRlZmluZWQuIFRoaXMgaXMgbm90IGV4cGVjdGVkIHRvIGhhcHBlbi4gUGxlYXNlICcgKyAncmVwb3J0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92aXNnbC9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvbmV3Jyk7XG4gIH1cbiAgLy8gZml4bWU6IGRvIHdlIG5lZWQgdGhlIGB1bmRlZmluZWRgIGNhc2VzIGZvciB0aGUgY2FtZXJhLXBhcmFtcz8gV2hlbiBhcmUgdGhleSB1c2VkIGluIHRoZSBtYXBzIEFQST9cbiAgT2JqZWN0LmFzc2lnbihyZWYuY3VycmVudCwge1xuICAgIGNlbnRlcjogKGNlbnRlciA9PSBudWxsID8gdm9pZCAwIDogY2VudGVyLnRvSlNPTigpKSB8fCB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIHpvb206IHpvb20gfHwgMCxcbiAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgIHRpbHQ6IHRpbHRcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBtdXRhYmxlIHJlZiBvYmplY3QgdG8gdHJhY2sgdGhlIGxhc3Qga25vd24gc3RhdGUgb2YgdGhlIG1hcCBjYW1lcmEuXG4gKiBUaGlzIGlzIHVzZWQgaW4gYHVzZU1hcENhbWVyYVBhcmFtc2AgdG8gcmVkdWNlIHN0dXR0ZXJpbmcgaW4gbm9ybWFsIG9wZXJhdGlvblxuICogYnkgYXZvaWRpbmcgdXBkYXRlcyBvZiB0aGUgbWFwIGNhbWVyYSB3aXRoIHZhbHVlcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhY2tlZENhbWVyYVN0YXRlUmVmKG1hcCkge1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZih7XG4gICAgY2VudGVyOiB7XG4gICAgICBsYXQ6IDAsXG4gICAgICBsbmc6IDBcbiAgICB9LFxuICAgIGhlYWRpbmc6IDAsXG4gICAgdGlsdDogMCxcbiAgICB6b29tOiAwXG4gIH0pO1xuICAvLyBSZWNvcmQgY2FtZXJhIHN0YXRlIHdpdGggZXZlcnkgYm91bmRzX2NoYW5nZWQgZXZlbnQgZGlzcGF0Y2hlZCBieSB0aGUgbWFwLlxuICAvLyBUaGlzIGRhdGEgaXMgdXNlZCB0byBwcmV2ZW50IGZlZWRpbmcgdGhlc2UgdmFsdWVzIGJhY2sgdG8gdGhlXG4gIC8vIG1hcC1pbnN0YW5jZSB3aGVuIGEgdHlwaWNhbCBcImNvbnRyb2xsZWQgY29tcG9uZW50XCIgc2V0dXAgKHN0YXRlIHZhcmlhYmxlIGlzXG4gIC8vIGZlZCBpbnRvIGFuZCB1cGRhdGVkIGJ5IHRoZSBtYXApLlxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIGhhbmRsZUJvdW5kc0NoYW5nZShtYXAsIHJlZik7XG4gICAgICAvLyBXaGVuIGFuIGV2ZW50IGlzIG9jY3VyZWQsIHdlIGhhdmUgdG8gdXBkYXRlIGR1cmluZyB0aGUgbmV4dCBjeWNsZS5cbiAgICAgIC8vIFRoZSBhcHBsaWNhdGlvbiBjb3VsZCBkZWNpZGUgdG8gaWdub3JlIHRoZSBldmVudCBhbmQgbm90IHVwZGF0ZSBhbnlcbiAgICAgIC8vIGNhbWVyYSBwcm9wcyBvZiB0aGUgbWFwLCBtZWFuaW5nIHRoYXQgaW4gdGhhdCBjYXNlIHdlIHdpbGwgaGF2ZSB0b1xuICAgICAgLy8gJ3VuZG8nIHRoZSBjaGFuZ2UgdG8gdGhlIGNhbWVyYS5cbiAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVyLnJlbW92ZSgpO1xuICB9LCBbbWFwLCBmb3JjZVVwZGF0ZV0pO1xuICByZXR1cm4gcmVmO1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMiA9IFtcImlkXCIsIFwiZGVmYXVsdEJvdW5kc1wiLCBcImRlZmF1bHRDZW50ZXJcIiwgXCJkZWZhdWx0Wm9vbVwiLCBcImRlZmF1bHRIZWFkaW5nXCIsIFwiZGVmYXVsdFRpbHRcIl07XG4vKipcbiAqIFRoZSBtYWluIGhvb2sgdGFrZXMgY2FyZSBvZiBjcmVhdGluZyBtYXAtaW5zdGFuY2VzIGFuZCByZWdpc3RlcmluZyB0aGVtIGluXG4gKiB0aGUgYXBpLXByb3ZpZGVyIGNvbnRleHQuXG4gKiBAcmV0dXJuIGEgdHVwbGUgb2YgdGhlIG1hcC1pbnN0YW5jZSBjcmVhdGVkIChvciBudWxsKSBhbmQgdGhlIGNhbGxiYWNrXG4gKiAgIHJlZiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXNzIHRoZSBtYXAtY29udGFpbmVyIGludG8gdGhpcyBob29rLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KSB7XG4gIGNvbnN0IGFwaUlzTG9hZGVkID0gdXNlQXBpSXNMb2FkZWQoKTtcbiAgY29uc3QgW21hcCwgc2V0TWFwXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY29udGFpbmVyLCBjb250YWluZXJSZWZdID0gdXNlQ2FsbGJhY2tSZWYoKTtcbiAgY29uc3QgY2FtZXJhU3RhdGVSZWYgPSB1c2VUcmFja2VkQ2FtZXJhU3RhdGVSZWYobWFwKTtcbiAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICBkZWZhdWx0Qm91bmRzLFxuICAgICAgZGVmYXVsdENlbnRlcixcbiAgICAgIGRlZmF1bHRab29tLFxuICAgICAgZGVmYXVsdEhlYWRpbmcsXG4gICAgICBkZWZhdWx0VGlsdFxuICAgIH0gPSBwcm9wcyxcbiAgICBtYXBPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQyKTtcbiAgLy8gYXBwbHkgZGVmYXVsdCBjYW1lcmEgcHJvcHMgaWYgYXZhaWxhYmxlIGFuZCBub3Qgb3ZlcndyaXR0ZW4gYnkgY29udHJvbGxlZCBwcm9wc1xuICBpZiAoIW1hcE9wdGlvbnMuY2VudGVyICYmIGRlZmF1bHRDZW50ZXIpIG1hcE9wdGlvbnMuY2VudGVyID0gZGVmYXVsdENlbnRlcjtcbiAgaWYgKCFtYXBPcHRpb25zLnpvb20gJiYgTnVtYmVyLmlzRmluaXRlKGRlZmF1bHRab29tKSkgbWFwT3B0aW9ucy56b29tID0gZGVmYXVsdFpvb207XG4gIGlmICghbWFwT3B0aW9ucy5oZWFkaW5nICYmIE51bWJlci5pc0Zpbml0ZShkZWZhdWx0SGVhZGluZykpIG1hcE9wdGlvbnMuaGVhZGluZyA9IGRlZmF1bHRIZWFkaW5nO1xuICBpZiAoIW1hcE9wdGlvbnMudGlsdCAmJiBOdW1iZXIuaXNGaW5pdGUoZGVmYXVsdFRpbHQpKSBtYXBPcHRpb25zLnRpbHQgPSBkZWZhdWx0VGlsdDtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWFwT3B0aW9ucykpIGlmIChtYXBPcHRpb25zW2tleV0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIG1hcE9wdGlvbnNba2V5XTtcbiAgY29uc3Qgc2F2ZWRNYXBTdGF0ZVJlZiA9IHVzZVJlZigpO1xuICAvLyBjcmVhdGUgdGhlIG1hcCBpbnN0YW5jZSBhbmQgcmVnaXN0ZXIgaXQgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRhaW5lciB8fCAhYXBpSXNMb2FkZWQpIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhZGRNYXBJbnN0YW5jZSxcbiAgICAgIHJlbW92ZU1hcEluc3RhbmNlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgbWFwSWQgPSBwcm9wcy5tYXBJZDtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKGNvbnRhaW5lciwgbWFwT3B0aW9ucyk7XG4gICAgc2V0TWFwKG5ld01hcCk7XG4gICAgYWRkTWFwSW5zdGFuY2UobmV3TWFwLCBpZCk7XG4gICAgaWYgKGRlZmF1bHRCb3VuZHMpIHtcbiAgICAgIG5ld01hcC5maXRCb3VuZHMoZGVmYXVsdEJvdW5kcyk7XG4gICAgfVxuICAgIC8vIHRoZSBzYXZlZE1hcFN0YXRlIGlzIHVzZWQgdG8gcmVzdG9yZSB0aGUgY2FtZXJhIHBhcmFtZXRlcnMgd2hlbiB0aGUgbWFwSWQgaXMgY2hhbmdlZFxuICAgIGlmIChzYXZlZE1hcFN0YXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWFwSWQ6IHNhdmVkTWFwSWQsXG4gICAgICAgIGNhbWVyYVN0YXRlOiBzYXZlZENhbWVyYVN0YXRlXG4gICAgICB9ID0gc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgaWYgKHNhdmVkTWFwSWQgIT09IG1hcElkKSB7XG4gICAgICAgIG5ld01hcC5zZXRPcHRpb25zKHNhdmVkQ2FtZXJhU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRNYXBTdGF0ZVJlZi5jdXJyZW50ID0ge1xuICAgICAgICBtYXBJZCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBjYW1lcmFTdGF0ZTogY2FtZXJhU3RhdGVSZWYuY3VycmVudFxuICAgICAgfTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnQtbGlzdGVuZXJzIHRvIG1pbmltaXplIG1lbW9yeS1sZWFrc1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhuZXdNYXApO1xuICAgICAgc2V0TWFwKG51bGwpO1xuICAgICAgcmVtb3ZlTWFwSW5zdGFuY2UoaWQpO1xuICAgIH07XG4gIH0sXG4gIC8vIHNvbWUgZGVwZW5kZW5jaWVzIGFyZSBpZ25vcmVkIGluIHRoZSBsaXN0IGJlbG93OlxuICAvLyAgLSBkZWZhdWx0Qm91bmRzIGFuZCB0aGUgZGVmYXVsdCogY2FtZXJhIHByb3BzIHdpbGwgb25seSBiZSB1c2VkIG9uY2UsIGFuZFxuICAvLyAgICBjaGFuZ2VzIHNob3VsZCBiZSBpZ25vcmVkXG4gIC8vICAtIG1hcE9wdGlvbnMgaGFzIHNwZWNpYWwgaG9va3MgdGhhdCB0YWtlIGNhcmUgb2YgdXBkYXRpbmcgdGhlIG9wdGlvbnNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbY29udGFpbmVyLCBhcGlJc0xvYWRlZCwgaWQsIHByb3BzLm1hcElkXSk7XG4gIHJldHVybiBbbWFwLCBjb250YWluZXJSZWYsIGNhbWVyYVN0YXRlUmVmXTtcbn1cblxuY29uc3QgR29vZ2xlTWFwc0NvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgTWFwID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgaWQsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgY29uc3QgbG9hZGluZ1N0YXR1cyA9IHVzZUFwaUxvYWRpbmdTdGF0dXMoKTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCc8TWFwPiBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBhbiA8QXBpUHJvdmlkZXI+IGNvbXBvbmVudC4nKTtcbiAgfVxuICBjb25zdCBbbWFwLCBtYXBSZWYsIGNhbWVyYVN0YXRlUmVmXSA9IHVzZU1hcEluc3RhbmNlKHByb3BzLCBjb250ZXh0KTtcbiAgdXNlTWFwQ2FtZXJhUGFyYW1zKG1hcCwgY2FtZXJhU3RhdGVSZWYsIHByb3BzKTtcbiAgdXNlTWFwRXZlbnRzKG1hcCwgcHJvcHMpO1xuICB1c2VNYXBPcHRpb25zKG1hcCwgcHJvcHMpO1xuICBjb25zdCBpc0RlY2tHbENvbnRyb2xsZWQgPSB1c2VEZWNrR0xDYW1lcmFVcGRhdGUobWFwLCBwcm9wcyk7XG4gIGNvbnN0IGlzQ29udHJvbGxlZEV4dGVybmFsbHkgPSAhIXByb3BzLmNvbnRyb2xsZWQ7XG4gIC8vIGRpc2FibGUgaW50ZXJhY3Rpb25zIHdpdGggdGhlIG1hcCBmb3IgZXh0ZXJuYWxseSBjb250cm9sbGVkIG1hcHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCkgcmV0dXJuO1xuICAgIC8vIGZpeG1lOiB0aGlzIGRvZXNuJ3Qgc2VlbSB0byBiZWxvbmcgaGVyZSAoYW5kIGl0J3MgbW9zdGx5IHRoZXJlIGZvciBjb252ZW5pZW5jZSBhbnl3YXkpLlxuICAgIC8vICAgVGhlIHJlYXNvbmluZyBpcyB0aGF0IGEgZGVjay5nbCBjYW52YXMgd2lsbCBiZSBwdXQgb24gdG9wIG9mIHRoZSBtYXAsIHJlbmRlcmluZ1xuICAgIC8vICAgYW55IGRlZmF1bHQgbWFwIGNvbnRyb2xzIHByZXR0eSBtdWNoIHVzZWxlc3NcbiAgICBpZiAoaXNEZWNrR2xDb250cm9sbGVkKSB7XG4gICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgIGRpc2FibGVEZWZhdWx0VUk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkaXNhYmxlIGFsbCBjb250cm9sLWlucHV0cyB3aGVuIHRoZSBtYXAgaXMgY29udHJvbGxlZCBleHRlcm5hbGx5XG4gICAgaWYgKGlzRGVja0dsQ29udHJvbGxlZCB8fCBpc0NvbnRyb2xsZWRFeHRlcm5hbGx5KSB7XG4gICAgICBtYXAuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdlc3R1cmVIYW5kbGluZzogJ25vbmUnLFxuICAgICAgICBrZXlib2FyZFNob3J0Y3V0czogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWFwLnNldE9wdGlvbnMoe1xuICAgICAgICBnZXN0dXJlSGFuZGxpbmc6IHByb3BzLmdlc3R1cmVIYW5kbGluZyxcbiAgICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IHByb3BzLmtleWJvYXJkU2hvcnRjdXRzXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbbWFwLCBpc0RlY2tHbENvbnRyb2xsZWQsIGlzQ29udHJvbGxlZEV4dGVybmFsbHksIHByb3BzLmdlc3R1cmVIYW5kbGluZywgcHJvcHMua2V5Ym9hcmRTaG9ydGN1dHNdKTtcbiAgLy8gc2V0dXAgYSBzdGFibGUgY2FtZXJhT3B0aW9ucyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyBkZXBlbmRlbmN5XG4gIGNvbnN0IGNlbnRlciA9IHByb3BzLmNlbnRlciA/IHRvTGF0TG5nTGl0ZXJhbChwcm9wcy5jZW50ZXIpIDogbnVsbDtcbiAgbGV0IGxhdCA9IG51bGw7XG4gIGxldCBsbmcgPSBudWxsO1xuICBpZiAoY2VudGVyICYmIE51bWJlci5pc0Zpbml0ZShjZW50ZXIubGF0KSAmJiBOdW1iZXIuaXNGaW5pdGUoY2VudGVyLmxuZykpIHtcbiAgICBsYXQgPSBjZW50ZXIubGF0O1xuICAgIGxuZyA9IGNlbnRlci5sbmc7XG4gIH1cbiAgY29uc3QgY2FtZXJhT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBfbGF0LCBfbG5nLCBfcHJvcHMkem9vbSwgX3Byb3BzJGhlYWRpbmcsIF9wcm9wcyR0aWx0O1xuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgbGF0OiAoX2xhdCA9IGxhdCkgIT0gbnVsbCA/IF9sYXQgOiAwLFxuICAgICAgICBsbmc6IChfbG5nID0gbG5nKSAhPSBudWxsID8gX2xuZyA6IDBcbiAgICAgIH0sXG4gICAgICB6b29tOiAoX3Byb3BzJHpvb20gPSBwcm9wcy56b29tKSAhPSBudWxsID8gX3Byb3BzJHpvb20gOiAwLFxuICAgICAgaGVhZGluZzogKF9wcm9wcyRoZWFkaW5nID0gcHJvcHMuaGVhZGluZykgIT0gbnVsbCA/IF9wcm9wcyRoZWFkaW5nIDogMCxcbiAgICAgIHRpbHQ6IChfcHJvcHMkdGlsdCA9IHByb3BzLnRpbHQpICE9IG51bGwgPyBfcHJvcHMkdGlsdCA6IDBcbiAgICB9O1xuICB9LCBbbGF0LCBsbmcsIHByb3BzLnpvb20sIHByb3BzLmhlYWRpbmcsIHByb3BzLnRpbHRdKTtcbiAgLy8gZXh0ZXJuYWxseSBjb250cm9sbGVkIG1vZGU6IHJlamVjdCBhbGwgY2FtZXJhIGNoYW5nZXMgdGhhdCBkb24ndCBjb3JyZXNwb25kIHRvIGNoYW5nZXMgaW4gcHJvcHNcbiAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhaXNDb250cm9sbGVkRXh0ZXJuYWxseSkgcmV0dXJuO1xuICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gbWFwLmFkZExpc3RlbmVyKCdib3VuZHNfY2hhbmdlZCcsICgpID0+IHtcbiAgICAgIG1hcC5tb3ZlQ2FtZXJhKGNhbWVyYU9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgfSwgW21hcCwgaXNDb250cm9sbGVkRXh0ZXJuYWxseSwgY2FtZXJhT3B0aW9uc10pO1xuICBjb25zdCBjb21iaW5lZFN0eWxlID0gdXNlTWVtbygoKSA9PiBfZXh0ZW5kcyh7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAvLyB3aGVuIHVzaW5nIGRlY2tnbCwgdGhlIG1hcCBzaG91bGQgYmUgc2VudCB0byB0aGUgYmFja1xuICAgIHpJbmRleDogaXNEZWNrR2xDb250cm9sbGVkID8gLTEgOiAwXG4gIH0sIHN0eWxlKSwgW3N0eWxlLCBpc0RlY2tHbENvbnRyb2xsZWRdKTtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIG1hcFxuICB9KSwgW21hcF0pO1xuICBpZiAobG9hZGluZ1N0YXR1cyA9PT0gQVBJTG9hZGluZ1N0YXR1cy5BVVRIX0ZBSUxVUkUpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IF9leHRlbmRzKHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgIH0sIGNsYXNzTmFtZSA/IHt9IDogY29tYmluZWRTdHlsZSksXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF1dGhGYWlsdXJlTWVzc2FnZSwgbnVsbCkpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBtYXBSZWYsXG4gICAgXCJkYXRhLXRlc3RpZFwiOiAnbWFwJyxcbiAgICBzdHlsZTogY2xhc3NOYW1lID8gdW5kZWZpbmVkIDogY29tYmluZWRTdHlsZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVxuICB9LCBpZCA/IHtcbiAgICBpZFxuICB9IDoge30pLCBtYXAgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChHb29nbGVNYXBzQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgfSwgY2hpbGRyZW4pIDogbnVsbCk7XG59O1xuTWFwLmRlY2tHTFZpZXdQcm9wcyA9IHRydWU7XG5cbmZ1bmN0aW9uIHVzZU1hcHNMaWJyYXJ5KG5hbWUpIHtcbiAgY29uc3QgYXBpSXNMb2FkZWQgPSB1c2VBcGlJc0xvYWRlZCgpO1xuICBjb25zdCBjdHggPSB1c2VDb250ZXh0KEFQSVByb3ZpZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhcGlJc0xvYWRlZCB8fCAhY3R4KSByZXR1cm47XG4gICAgLy8gVHJpZ2dlciBsb2FkaW5nIHRoZSBsaWJyYXJpZXMgdmlhIG91ciBwcm94eS1tZXRob2QuXG4gICAgLy8gVGhlIHJldHVybmVkIHByb21pc2UgaXMgaWdub3JlZCwgc2luY2UgaW1wb3J0TGlicmFyeSB3aWxsIHVwZGF0ZSBsb2FkZWRMaWJyYXJpZXNcbiAgICAvLyBsaXN0IGluIHRoZSBjb250ZXh0LCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgIHZvaWQgY3R4LmltcG9ydExpYnJhcnkobmFtZSk7XG4gIH0sIFthcGlJc0xvYWRlZCwgY3R4LCBuYW1lXSk7XG4gIHJldHVybiAoY3R4ID09IG51bGwgPyB2b2lkIDAgOiBjdHgubG9hZGVkTGlicmFyaWVzW25hbWVdKSB8fCBudWxsO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5ICovXG5jb25zdCBBZHZhbmNlZE1hcmtlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpIHtcbiAgdmFyIF91c2VDb250ZXh0O1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjb250ZW50Q29udGFpbmVyLCBzZXRDb250ZW50Q29udGFpbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3QgbWFya2VyTGlicmFyeSA9IHVzZU1hcHNMaWJyYXJ5KCdtYXJrZXInKTtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZSxcbiAgICBvbkNsaWNrLFxuICAgIG9uRHJhZyxcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWdFbmQsXG4gICAgY29sbGlzaW9uQmVoYXZpb3IsXG4gICAgZHJhZ2dhYmxlLFxuICAgIHBvc2l0aW9uLFxuICAgIHRpdGxlLFxuICAgIHpJbmRleFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG51bUNoaWxkcyA9IENoaWxkcmVuLmNvdW50KGNoaWxkcmVuKTtcbiAgLy8gY3JlYXRlIG1hcmtlciBpbnN0YW5jZSBhbmQgYWRkIGl0IHRvIHRoZSBtYXAgd2hlbiBtYXAgYmVjb21lcyBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW1hcCB8fCAhbWFya2VyTGlicmFyeSkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld01hcmtlciA9IG5ldyBtYXJrZXJMaWJyYXJ5LkFkdmFuY2VkTWFya2VyRWxlbWVudCgpO1xuICAgIG5ld01hcmtlci5tYXAgPSBtYXA7XG4gICAgc2V0TWFya2VyKG5ld01hcmtlcik7XG4gICAgLy8gY3JlYXRlIGNvbnRhaW5lciBmb3IgbWFya2VyIGNvbnRlbnQgaWYgdGhlcmUgYXJlIGNoaWxkcmVuXG4gICAgaWYgKG51bUNoaWxkcyA+IDApIHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZiAoY2xhc3NOYW1lKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICBuZXdNYXJrZXIuY29udGVudCA9IGVsO1xuICAgICAgc2V0Q29udGVudENvbnRhaW5lcihlbCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBuZXdNYXJrZXIubWFwID0gbnVsbDtcbiAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgfTtcbiAgICAvLyBXZSBkbyBub3Qgd2FudCB0byByZS1yZW5kZXIgdGhlIHdob2xlIG1hcmtlciB3aGVuIHRoZSBjbGFzc05hbWUgY2hhbmdlc1xuICAgIC8vIGJlY2F1c2UgdGhhdCBjYXVzZXMgYSBzaG9ydCBmbGlja2VyaW5nIG9mIHRoZSBtYXJrZXIuXG4gICAgLy8gVGhlIGNsYXNzTmFtZSB1cGRhdGUgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vIEV4Y2x1ZGluZyB0aGUgY2xhc3NOYW1lIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXkgb25tIHB1cnBvc2UgaGVyZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW21hcCwgbWFya2VyTGlicmFyeSwgbnVtQ2hpbGRzXSk7XG4gIC8vIHVwZGF0ZSBjbGFzc05hbWUgb2YgYWR2YW5jZWQgbWFya2VyIGVsZW1lbnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNvbnRlbnRDb250YWluZXIpIHJldHVybjtcbiAgICBjb250ZW50Q29udGFpbmVyLmNsYXNzTmFtZSA9IGNsYXNzTmFtZSAhPSBudWxsID8gY2xhc3NOYW1lIDogJyc7XG4gIH0sIFtjb250ZW50Q29udGFpbmVyLCBjbGFzc05hbWVdKTtcbiAgLy8gYmluZCBhbGwgbWFya2VyIGV2ZW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgaWYgKG9uQ2xpY2spIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdjbGljaycsIG9uQ2xpY2spO1xuICAgIGlmIChvbkRyYWcpIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnJywgb25EcmFnKTtcbiAgICBpZiAob25EcmFnU3RhcnQpIGdtZS5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgaWYgKG9uRHJhZ0VuZCkgZ21lLmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpO1xuICAgIGlmICgob25EcmFnIHx8IG9uRHJhZ1N0YXJ0IHx8IG9uRHJhZ0VuZCkgJiYgIWRyYWdnYWJsZSkge1xuICAgICAgY29uc29sZS53YXJuKCdZb3UgbmVlZCB0byBzZXQgdGhlIG1hcmtlciB0byBkcmFnZ2FibGUgdG8gbGlzdGVuIHRvIGRyYWctZXZlbnRzLicpO1xuICAgIH1cbiAgICBjb25zdCBtID0gbWFya2VyO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICB9O1xuICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uQ2xpY2ssIG9uRHJhZ1N0YXJ0LCBvbkRyYWcsIG9uRHJhZ0VuZF0pO1xuICAvLyB1cGRhdGUgb3RoZXIgbWFya2VyIHByb3BzIHdoZW4gY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpIG1hcmtlci5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIGlmIChkcmFnZ2FibGUgIT09IHVuZGVmaW5lZCkgbWFya2VyLmdtcERyYWdnYWJsZSA9IGRyYWdnYWJsZTtcbiAgICBpZiAoY29sbGlzaW9uQmVoYXZpb3IgIT09IHVuZGVmaW5lZCkgbWFya2VyLmNvbGxpc2lvbkJlaGF2aW9yID0gY29sbGlzaW9uQmVoYXZpb3I7XG4gICAgaWYgKHpJbmRleCAhPT0gdW5kZWZpbmVkKSBtYXJrZXIuekluZGV4ID0gekluZGV4O1xuICAgIGlmICh0eXBlb2YgdGl0bGUgPT09ICdzdHJpbmcnKSBtYXJrZXIudGl0bGUgPSB0aXRsZTtcbiAgfSwgW21hcmtlciwgcG9zaXRpb24sIGRyYWdnYWJsZSwgY29sbGlzaW9uQmVoYXZpb3IsIHpJbmRleCwgdGl0bGVdKTtcbiAgcmV0dXJuIFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdO1xufVxuY29uc3QgQWR2YW5jZWRNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFttYXJrZXIsIGNvbnRlbnRDb250YWluZXJdID0gdXNlQWR2YW5jZWRNYXJrZXIocHJvcHMpO1xuICBjb25zdCBhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gbWFya2VyID8ge1xuICAgIG1hcmtlclxuICB9IDogbnVsbCwgW21hcmtlcl0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gbWFya2VyLCBbbWFya2VyXSk7XG4gIGlmICghbWFya2VyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEFkdmFuY2VkTWFya2VyQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhZHZhbmNlZE1hcmtlckNvbnRleHRWYWx1ZVxuICB9LCBjb250ZW50Q29udGFpbmVyICE9PSBudWxsICYmIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGVudENvbnRhaW5lcikpO1xufSk7XG5mdW5jdGlvbiB1c2VBZHZhbmNlZE1hcmtlclJlZigpIHtcbiAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCByZWZDYWxsYmFjayA9IHVzZUNhbGxiYWNrKG0gPT4ge1xuICAgIHNldE1hcmtlcihtKTtcbiAgfSwgW10pO1xuICByZXR1cm4gW3JlZkNhbGxiYWNrLCBtYXJrZXJdO1xufVxuXG5jb25zdCBfZXhjbHVkZWQkMSA9IFtcImNoaWxkcmVuXCIsIFwiYW5jaG9yXCIsIFwic2hvdWxkRm9jdXNcIiwgXCJvbkNsb3NlQ2xpY2tcIl07XG4vKipcbiAqIENvbXBvbmVudCB0byByZW5kZXIgYSBHb29nbGUgTWFwcyBJbmZvIFdpbmRvd1xuICovXG5jb25zdCBJbmZvV2luZG93ID0gcHJvcHMgPT4ge1xuICB2YXIgX3VzZUNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgYW5jaG9yLFxuICAgICAgc2hvdWxkRm9jdXMsXG4gICAgICBvbkNsb3NlQ2xpY2tcbiAgICB9ID0gcHJvcHMsXG4gICAgaW5mb1dpbmRvd09wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3QgaW5mb1dpbmRvd1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2NvbnRlbnRDb250YWluZXIsIHNldENvbnRlbnRDb250YWluZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIGNyZWF0ZSBpbmZvd2luZG93IG9uY2UgbWFwIGlzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5mb3dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KGluZm9XaW5kb3dPcHRpb25zKTtcbiAgICAvLyBBZGQgY29udGVudCB0byBpbmZvIHdpbmRvd1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbmV3SW5mb3dpbmRvdy5zZXRDb250ZW50KGVsKTtcbiAgICBpbmZvV2luZG93UmVmLmN1cnJlbnQgPSBuZXdJbmZvd2luZG93O1xuICAgIHNldENvbnRlbnRDb250YWluZXIoZWwpO1xuICAgIC8vIENsZWFudXAgaW5mbyB3aW5kb3cgYW5kIGV2ZW50IGxpc3RlbmVycyBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmNsZWFySW5zdGFuY2VMaXN0ZW5lcnMobmV3SW5mb3dpbmRvdyk7XG4gICAgICBuZXdJbmZvd2luZG93LmNsb3NlKCk7XG4gICAgICBlbC5yZW1vdmUoKTtcbiAgICAgIHNldENvbnRlbnRDb250YWluZXIobnVsbCk7XG4gICAgfTtcbiAgICAvLyBgaW5mb1dpbmRvd09wdGlvbnNgIGlzIG1pc3NpbmcgZnJvbSBkZXBlbmRlbmNpZXM6XG4gICAgLy9cbiAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHJlLXJlbmRlciBhIHdob2xlIG5ldyBpbmZvd2luZG93XG4gICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBjaGFuZ2UgdG8gcHJldmVudCBmbGlja2VyaW5nLlxuICAgIC8vIFVwZGF0ZSBvZiBpbmZvV2luZG93IG9wdGlvbnMgaXMgaGFuZGxlZCBpbiB0aGUgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwLCBjaGlsZHJlbl0pO1xuICAvLyBVcGRhdGUgaW5mb1dpbmRvd09wdGlvbnNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX2luZm9XaW5kb3dSZWYkY3VycmVuO1xuICAgIChfaW5mb1dpbmRvd1JlZiRjdXJyZW4gPSBpbmZvV2luZG93UmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2luZm9XaW5kb3dSZWYkY3VycmVuLnNldE9wdGlvbnMoaW5mb1dpbmRvd09wdGlvbnMpO1xuICB9LCBbaW5mb1dpbmRvd09wdGlvbnNdKTtcbiAgLy8gSGFuZGxlIHRoZSBjbG9zZSBjbGljayBjYWxsYmFja1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW5mb1dpbmRvd1JlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbGV0IGxpc3RlbmVyID0gbnVsbDtcbiAgICBpZiAob25DbG9zZUNsaWNrKSB7XG4gICAgICBsaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3dSZWYuY3VycmVudCwgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lci5yZW1vdmUoKTtcbiAgICB9O1xuICB9LCBbb25DbG9zZUNsaWNrXSk7XG4gIC8vIE9wZW4gaW5mbyB3aW5kb3cgYWZ0ZXIgY29udGVudCBjb250YWluZXIgaXMgc2V0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gYW5jaG9yID09PSBudWxsIG1lYW5zIGFuIGFuY2hvciBpcyBkZWZpbmVkIGJ1dCBub3QgcmVhZHkgeWV0LlxuICAgIGlmICghY29udGVudENvbnRhaW5lciB8fCAhaW5mb1dpbmRvd1JlZi5jdXJyZW50IHx8IGFuY2hvciA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IG9wZW5PcHRpb25zID0ge1xuICAgICAgbWFwXG4gICAgfTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICBvcGVuT3B0aW9ucy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIGlmIChzaG91bGRGb2N1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcGVuT3B0aW9ucy5zaG91bGRGb2N1cyA9IHNob3VsZEZvY3VzO1xuICAgIH1cbiAgICBpbmZvV2luZG93UmVmLmN1cnJlbnQub3BlbihvcGVuT3B0aW9ucyk7XG4gIH0sIFtjb250ZW50Q29udGFpbmVyLCBpbmZvV2luZG93UmVmLCBhbmNob3IsIG1hcCwgc2hvdWxkRm9jdXNdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjb250ZW50Q29udGFpbmVyICE9PSBudWxsICYmIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGVudENvbnRhaW5lcikpO1xufTtcblxuY29uc3Qgc2hvd25NZXNzYWdlcyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGxvZ0Vycm9yT25jZSguLi5hcmdzKSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KGFyZ3MpO1xuICBpZiAoIXNob3duTWVzc2FnZXMuaGFzKGtleSkpIHtcbiAgICBzaG93bk1lc3NhZ2VzLmFkZChrZXkpO1xuICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBtYXAtaW5zdGFuY2UgZnJvbSB0aGUgY29udGV4dC4gVGhpcyBpcyBlaXRoZXIgYW4gaW5zdGFuY2VcbiAqIGlkZW50aWZpZWQgYnkgaWQgb3IgdGhlIHBhcmVudCBtYXAgaW5zdGFuY2UgaWYgbm8gaWQgaXMgc3BlY2lmaWVkLlxuICogUmV0dXJucyBudWxsIGlmIG5laXRoZXIgY2FuIGJlIGZvdW5kLlxuICovXG5jb25zdCB1c2VNYXAgPSAoaWQgPSBudWxsKSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQoQVBJUHJvdmlkZXJDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIG1hcFxuICB9ID0gdXNlQ29udGV4dChHb29nbGVNYXBzQ29udGV4dCkgfHwge307XG4gIGlmIChjdHggPT09IG51bGwpIHtcbiAgICBsb2dFcnJvck9uY2UoJ3VzZU1hcCgpOiBmYWlsZWQgdG8gcmV0cmlldmUgQVBJUHJvdmlkZXJDb250ZXh0LiAnICsgJ01ha2Ugc3VyZSB0aGF0IHRoZSA8QVBJUHJvdmlkZXI+IGNvbXBvbmVudCBleGlzdHMgYW5kIHRoYXQgdGhlICcgKyAnY29tcG9uZW50IHlvdSBhcmUgY2FsbGluZyBgdXNlTWFwKClgIGZyb20gaXMgYSBzaWJsaW5nIG9mIHRoZSAnICsgJzxBUElQcm92aWRlcj4uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3Qge1xuICAgIG1hcEluc3RhbmNlc1xuICB9ID0gY3R4O1xuICAvLyBpZiBhbiBpZCBpcyBzcGVjaWZpZWQsIHRoZSBjb3JyZXNwb25kaW5nIG1hcCBvciBudWxsIGlzIHJldHVybmVkXG4gIGlmIChpZCAhPT0gbnVsbCkgcmV0dXJuIG1hcEluc3RhbmNlc1tpZF0gfHwgbnVsbDtcbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIGNsb3Nlc3QgYW5jZXN0b3JcbiAgaWYgKG1hcCkgcmV0dXJuIG1hcDtcbiAgLy8gZmluYWxseSwgcmV0dXJuIHRoZSBkZWZhdWx0IG1hcCBpbnN0YW5jZVxuICByZXR1cm4gbWFwSW5zdGFuY2VzWydkZWZhdWx0J10gfHwgbnVsbDtcbn07XG5cbi8qKlxuICogQ29weSBvZiB0aGUgYGdvb2dsZS5tYXBzLkNvbnRyb2xQb3NpdGlvbmAgY29uc3RhbnRzLlxuICogVGhleSBoYXZlIHRvIGJlIGR1cGxpY2F0ZWQgaGVyZSBzaW5jZSB3ZSBjYW4ndCB3YWl0IGZvciB0aGUgbWFwcyBBUEkgdG8gbG9hZCB0byBiZSBhYmxlIHRvIHVzZSB0aGVtLlxuICovXG5jb25zdCBDb250cm9sUG9zaXRpb24gPSB7XG4gIFRPUF9MRUZUOiAxLFxuICBUT1BfQ0VOVEVSOiAyLFxuICBUT1A6IDIsXG4gIFRPUF9SSUdIVDogMyxcbiAgTEVGVF9DRU5URVI6IDQsXG4gIExFRlRfVE9QOiA1LFxuICBMRUZUOiA1LFxuICBMRUZUX0JPVFRPTTogNixcbiAgUklHSFRfVE9QOiA3LFxuICBSSUdIVDogNyxcbiAgUklHSFRfQ0VOVEVSOiA4LFxuICBSSUdIVF9CT1RUT006IDksXG4gIEJPVFRPTV9MRUZUOiAxMCxcbiAgQk9UVE9NX0NFTlRFUjogMTEsXG4gIEJPVFRPTTogMTEsXG4gIEJPVFRPTV9SSUdIVDogMTIsXG4gIENFTlRFUjogMTMsXG4gIEJMT0NLX1NUQVJUX0lOTElORV9TVEFSVDogMTQsXG4gIEJMT0NLX1NUQVJUX0lOTElORV9DRU5URVI6IDE1LFxuICBCTE9DS19TVEFSVF9JTkxJTkVfRU5EOiAxNixcbiAgSU5MSU5FX1NUQVJUX0JMT0NLX0NFTlRFUjogMTcsXG4gIElOTElORV9TVEFSVF9CTE9DS19TVEFSVDogMTgsXG4gIElOTElORV9TVEFSVF9CTE9DS19FTkQ6IDE5LFxuICBJTkxJTkVfRU5EX0JMT0NLX1NUQVJUOiAyMCxcbiAgSU5MSU5FX0VORF9CTE9DS19DRU5URVI6IDIxLFxuICBJTkxJTkVfRU5EX0JMT0NLX0VORDogMjIsXG4gIEJMT0NLX0VORF9JTkxJTkVfU1RBUlQ6IDIzLFxuICBCTE9DS19FTkRfSU5MSU5FX0NFTlRFUjogMjQsXG4gIEJMT0NLX0VORF9JTkxJTkVfRU5EOiAyNVxufTtcbmNvbnN0IE1hcENvbnRyb2wgPSAoe1xuICBjaGlsZHJlbixcbiAgcG9zaXRpb25cbn0pID0+IHtcbiAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIFtdKTtcbiAgY29uc3QgbWFwID0gdXNlTWFwKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXApIHJldHVybjtcbiAgICBjb25zdCBjb250cm9scyA9IG1hcC5jb250cm9sc1twb3NpdGlvbl07XG4gICAgY29udHJvbHMucHVzaChjb250cm9sQ29udGFpbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgY29udHJvbHNBcnJheSA9IGNvbnRyb2xzLmdldEFycmF5KCk7XG4gICAgICAvLyBjb250cm9sc0FycmF5IGNvdWxkIGJlIHVuZGVmaW5lZCBpZiB0aGUgbWFwIGlzIGluIGFuIHVuZGVmaW5lZCBzdGF0ZSAoZS5nLiBpbnZhbGlkIEFQSS1rZXksIHNlZSAjMjc2XG4gICAgICBpZiAoIWNvbnRyb2xzQXJyYXkpIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29udHJvbHNBcnJheS5pbmRleE9mKGNvbnRyb2xDb250YWluZXIpO1xuICAgICAgY29udHJvbHMucmVtb3ZlQXQoaW5kZXgpO1xuICAgIH07XG4gIH0sIFtjb250cm9sQ29udGFpbmVyLCBtYXAsIHBvc2l0aW9uXSk7XG4gIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRyb2xDb250YWluZXIpO1xufTtcblxuY29uc3QgX2V4Y2x1ZGVkID0gW1wib25DbGlja1wiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnRW5kXCIsIFwib25Nb3VzZU92ZXJcIiwgXCJvbk1vdXNlT3V0XCJdO1xuZnVuY3Rpb24gdXNlTWFya2VyKHByb3BzKSB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3QgW21hcmtlciwgc2V0TWFya2VyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBtYXAgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEdvb2dsZU1hcHNDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF91c2VDb250ZXh0Lm1hcDtcbiAgY29uc3Qge1xuICAgICAgb25DbGljayxcbiAgICAgIG9uRHJhZyxcbiAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgb25EcmFnRW5kLFxuICAgICAgb25Nb3VzZU92ZXIsXG4gICAgICBvbk1vdXNlT3V0XG4gICAgfSA9IHByb3BzLFxuICAgIG1hcmtlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkKTtcbiAgY29uc3Qge1xuICAgIHBvc2l0aW9uLFxuICAgIGRyYWdnYWJsZVxuICB9ID0gbWFya2VyT3B0aW9ucztcbiAgLy8gY3JlYXRlIG1hcmtlciBpbnN0YW5jZSBhbmQgYWRkIHRvIHRoZSBtYXAgb25jZSB0aGUgbWFwIGlzIGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSB7XG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIGNvbnNvbGUuZXJyb3IoJzxNYXJrZXI+IGhhcyB0byBiZSBpbnNpZGUgYSBNYXAgY29tcG9uZW50LicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdNYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgIG5ld01hcmtlci5zZXRNYXAobWFwKTtcbiAgICBzZXRNYXJrZXIobmV3TWFya2VyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbmV3TWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgIHNldE1hcmtlcihudWxsKTtcbiAgICB9O1xuICAgIC8vIFdlIGRvIG5vdCB3YW50IHRvIHJlLXJlbmRlciB0aGUgd2hvbGUgbWFya2VyIHdoZW4gdGhlIG9wdGlvbnMgY2hhbmdlLlxuICAgIC8vIE1hcmtlciBvcHRpb25zIHVwZGF0ZSBpcyBoYW5kbGVkIGluIGEgdXNlRWZmZWN0IGJlbG93LlxuICAgIC8vIEV4Y2x1ZGluZyBtYXJrZXJPcHRpb25zIGZyb20gZGVwZW5kZW5jeSBhcnJheSBvbiBwdXJwb3NlIGhlcmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbbWFwXSk7XG4gIC8vIGF0dGFjaCBhbmQgcmUtYXR0YWNoIGV2ZW50LWhhbmRsZXJzIHdoZW4gYW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFya2VyKSByZXR1cm47XG4gICAgY29uc3QgbSA9IG1hcmtlcjtcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgZ21lID0gZ29vZ2xlLm1hcHMuZXZlbnQ7XG4gICAgaWYgKG9uQ2xpY2spIGdtZS5hZGRMaXN0ZW5lcihtLCAnY2xpY2snLCBvbkNsaWNrKTtcbiAgICBpZiAob25EcmFnKSBnbWUuYWRkTGlzdGVuZXIobSwgJ2RyYWcnLCBvbkRyYWcpO1xuICAgIGlmIChvbkRyYWdTdGFydCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCk7XG4gICAgaWYgKG9uRHJhZ0VuZCkgZ21lLmFkZExpc3RlbmVyKG0sICdkcmFnZW5kJywgb25EcmFnRW5kKTtcbiAgICBpZiAob25Nb3VzZU92ZXIpIGdtZS5hZGRMaXN0ZW5lcihtLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpO1xuICAgIGlmIChvbk1vdXNlT3V0KSBnbWUuYWRkTGlzdGVuZXIobSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCk7XG4gICAgbWFya2VyLnNldERyYWdnYWJsZShCb29sZWFuKGRyYWdnYWJsZSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBnbWUuY2xlYXJJbnN0YW5jZUxpc3RlbmVycyhtKTtcbiAgICB9O1xuICB9LCBbbWFya2VyLCBkcmFnZ2FibGUsIG9uQ2xpY2ssIG9uRHJhZywgb25EcmFnU3RhcnQsIG9uRHJhZ0VuZCwgb25Nb3VzZU92ZXIsIG9uTW91c2VPdXRdKTtcbiAgLy8gdXBkYXRlIG1hcmtlck9wdGlvbnMgKG5vdGUgdGhlIGRlcGVuZGVuY2llcyBhcmVuJ3QgcHJvcGVybHkgY2hlY2tlZFxuICAvLyBoZXJlLCB3ZSBqdXN0IGFzc3VtZSB0aGF0IHNldE9wdGlvbnMgaXMgc21hcnQgZW5vdWdoIHRvIG5vdCB3YXN0ZSBhXG4gIC8vIGxvdCBvZiB0aW1lIHVwZGF0aW5nIHZhbHVlcyB0aGF0IGRpZG4ndCBjaGFuZ2UpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybjtcbiAgICBpZiAobWFya2VyT3B0aW9ucykgbWFya2VyLnNldE9wdGlvbnMobWFya2VyT3B0aW9ucyk7XG4gIH0sIFttYXJrZXIsIG1hcmtlck9wdGlvbnNdKTtcbiAgLy8gdXBkYXRlIHBvc2l0aW9uIHdoZW4gY2hhbmdlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNob3VsZCBub3QgdXBkYXRlIHBvc2l0aW9uIHdoZW4gZHJhZ2dhYmxlXG4gICAgaWYgKGRyYWdnYWJsZSB8fCAhcG9zaXRpb24gfHwgIW1hcmtlcikgcmV0dXJuO1xuICAgIG1hcmtlci5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH0sIFtkcmFnZ2FibGUsIHBvc2l0aW9uLCBtYXJrZXJdKTtcbiAgcmV0dXJuIG1hcmtlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIEdvb2dsZSBNYXBzIE1hcmtlciBvbiBhIG1hcFxuICovXG5jb25zdCBNYXJrZXIgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IHVzZU1hcmtlcihwcm9wcyk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiBtYXJrZXIsIFttYXJrZXJdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbn0pO1xuZnVuY3Rpb24gdXNlTWFya2VyUmVmKCkge1xuICBjb25zdCBbbWFya2VyLCBzZXRNYXJrZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2sobSA9PiB7XG4gICAgc2V0TWFya2VyKG0pO1xuICB9LCBbXSk7XG4gIHJldHVybiBbcmVmQ2FsbGJhY2ssIG1hcmtlcl07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IHRvIHJlbmRlciBhIGdvb2dsZSBtYXBzIG1hcmtlciBQaW4gVmlld1xuICovXG5jb25zdCBQaW4gPSBwcm9wcyA9PiB7XG4gIHZhciBfdXNlQ29udGV4dDtcbiAgY29uc3QgYWR2YW5jZWRNYXJrZXIgPSAoX3VzZUNvbnRleHQgPSB1c2VDb250ZXh0KEFkdmFuY2VkTWFya2VyQ29udGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdXNlQ29udGV4dC5tYXJrZXI7XG4gIGNvbnN0IGdseXBoQ29udGFpbmVyID0gdXNlTWVtbygoKSA9PiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgW10pO1xuICAvLyBDcmVhdGUgUGluIFZpZXcgaW5zdGFuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFkdmFuY2VkTWFya2VyKSB7XG4gICAgICBpZiAoYWR2YW5jZWRNYXJrZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgPFBpbj4gY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIDxBZHZhbmNlZE1hcmtlcj4uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9wcy5nbHlwaCAmJiBwcm9wcy5jaGlsZHJlbikge1xuICAgICAgbG9nRXJyb3JPbmNlKCdUaGUgPFBpbj4gY29tcG9uZW50IG9ubHkgdXNlcyBjaGlsZHJlbiB0byByZW5kZXIgdGhlIGdseXBoIGlmIGJvdGggdGhlIGdseXBoIHByb3BlcnR5IGFuZCBjaGlsZHJlbiBhcmUgcHJlc2VudC4nKTtcbiAgICB9XG4gICAgaWYgKENoaWxkcmVuLmNvdW50KHByb3BzLmNoaWxkcmVuKSA+IDEpIHtcbiAgICAgIGxvZ0Vycm9yT25jZSgnUGFzc2luZyBtdWx0aXBsZSBjaGlsZHJlbiB0byB0aGUgPFBpbj4gY29tcG9uZW50IG1pZ2h0IGxlYWQgdG8gdW5leHBlY3RlZCByZXN1bHRzLicpO1xuICAgIH1cbiAgICBjb25zdCBwaW5WaWV3T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBwcm9wcyk7XG4gICAgY29uc3QgcGluRWxlbWVudCA9IG5ldyBnb29nbGUubWFwcy5tYXJrZXIuUGluRWxlbWVudChwaW5WaWV3T3B0aW9ucyk7XG4gICAgLy8gU2V0IGdseXBoIHRvIGdseXBoIGNvbnRhaW5lciBpZiBjaGlsZHJlbiBhcmUgcHJlc2VudCAocmVuZGVyZWQgdmlhIHBvcnRhbCkuXG4gICAgLy8gSWYgYm90aCBwcm9wcy5nbHlwaCBhbmQgcHJvcHMuY2hpbGRyZW4gYXJlIHByZXNlbnQsIHByb3BzLmNoaWxkcmVuIHRha2VzIHByaW9yaXR5LlxuICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgcGluRWxlbWVudC5nbHlwaCA9IGdseXBoQ29udGFpbmVyO1xuICAgIH1cbiAgICAvLyBTZXQgY29udGVudCBvZiBBZHZhbmNlZCBNYXJrZXIgVmlldyB0byB0aGUgUGluIFZpZXcgZWxlbWVudFxuICAgIGFkdmFuY2VkTWFya2VyLmNvbnRlbnQgPSBwaW5FbGVtZW50LmVsZW1lbnQ7XG4gIH0sIFthZHZhbmNlZE1hcmtlciwgZ2x5cGhDb250YWluZXIsIHByb3BzXSk7XG4gIHJldHVybiBjcmVhdGVQb3J0YWwocHJvcHMuY2hpbGRyZW4sIGdseXBoQ29udGFpbmVyKTtcbn07XG5cbmNvbnN0IG1hcExpbmVhciA9ICh4LCBhMSwgYTIsIGIxLCBiMikgPT4gYjEgKyAoeCAtIGExKSAqIChiMiAtIGIxKSAvIChhMiAtIGExKTtcbmNvbnN0IGdldE1hcE1heFRpbHQgPSB6b29tID0+IHtcbiAgaWYgKHpvb20gPD0gMTApIHtcbiAgICByZXR1cm4gMzA7XG4gIH1cbiAgaWYgKHpvb20gPj0gMTUuNSkge1xuICAgIHJldHVybiA2Ny41O1xuICB9XG4gIC8vIHJhbmdlIFsxMC4uLjE0XVxuICBpZiAoem9vbSA8PSAxNCkge1xuICAgIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTAsIDE0LCAzMCwgNDUpO1xuICB9XG4gIC8vIHJhbmdlIFsxNC4uLjE1LjVdXG4gIHJldHVybiBtYXBMaW5lYXIoem9vbSwgMTQsIDE1LjUsIDQ1LCA2Ny41KTtcbn07XG4vKipcbiAqIEZ1bmN0aW9uIHRvIGxpbWl0IHRoZSB0aWx0IHJhbmdlIG9mIHRoZSBnb29nbGUgbWFwcyBtYXAgd2hlbiB1cGRhdGluZyB0aGUgdmlldyBzdGF0ZVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgbGltaXRUaWx0UmFuZ2UgPSAoe1xuICB2aWV3U3RhdGVcbn0pID0+IHtcbiAgY29uc3QgcGl0Y2ggPSB2aWV3U3RhdGUucGl0Y2g7XG4gIGNvbnN0IGdtWm9vbSA9IHZpZXdTdGF0ZS56b29tICsgMTtcbiAgY29uc3QgbWF4VGlsdCA9IGdldE1hcE1heFRpbHQoZ21ab29tKTtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCB2aWV3U3RhdGUsIHtcbiAgICBmb3Z5OiAyNSxcbiAgICBwaXRjaDogTWF0aC5taW4obWF4VGlsdCwgcGl0Y2gpXG4gIH0pO1xufTtcblxuZXhwb3J0IHsgQVBJTG9hZGluZ1N0YXR1cywgQVBJUHJvdmlkZXIsIEFQSVByb3ZpZGVyQ29udGV4dCwgQWR2YW5jZWRNYXJrZXIsIEFkdmFuY2VkTWFya2VyQ29udGV4dCwgQ29udHJvbFBvc2l0aW9uLCBHb29nbGVNYXBzQ29udGV4dCwgSW5mb1dpbmRvdywgTWFwLCBNYXBDb250cm9sLCBNYXJrZXIsIFBpbiwgaXNMYXRMbmdMaXRlcmFsLCBsYXRMbmdFcXVhbHMsIGxpbWl0VGlsdFJhbmdlLCB0b0xhdExuZ0xpdGVyYWwsIHVzZUFkdmFuY2VkTWFya2VyUmVmLCB1c2VBcGlJc0xvYWRlZCwgdXNlQXBpTG9hZGluZ1N0YXR1cywgdXNlTWFwLCB1c2VNYXBzTGlicmFyeSwgdXNlTWFya2VyUmVmIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tb2Rlcm4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vis.gl/react-google-maps/dist/index.modern.mjs\n");

/***/ })

};
;